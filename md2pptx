#!/usr/bin/env python3

"""
md2pptx - Converts (a subset of) Markdown to Powerpoint (PPTX)

First argument is file to write to

Reads from stdin
"""

import re
import sys
import os
import time
from pptx import Presentation
from pptx import __version__ as pptx_version
from pptx.util import Inches, Pt
from pptx.dml.color import RGBColor, MSO_THEME_COLOR
from pptx.enum.text import MSO_AUTO_SIZE, PP_ALIGN
from pptx.enum.shapes import PP_PLACEHOLDER
from pptx.enum.shapes import MSO_SHAPE, MSO_CONNECTOR
from pptx.enum.text import MSO_ANCHOR, PP_ALIGN
from pptx.enum.action import PP_ACTION
from pptx.enum.dml import MSO_PATTERN
from pptx.dml.color import RGBColor
import imghdr, struct
import datetime
import html.parser
from pptx.oxml.xmlchemy import OxmlElement
from pathlib import Path
import urllib.request
import tempfile
import copy
import platform

# import xml.etree
from lxml import etree

# Try to import CairoSVG - which might not be installed.
# Flag availability or otherwise
try:
    import cairosvg

    have_cairosvg = True
except:
    have_cairosvg = False

md2pptx_level = "2.4.2"
md2pptx_date = "17 October, 2021"


class SlideInfo:
    def __init__(
        self,
        titleText,
        subtitleText,
        blockType,
        bullets,
        tableRows,
        cards,
        code,
        sequence,
    ):
        self.titleText = titleText
        self.subtitleText = subtitleText
        self.blockType = blockType
        self.bullets = bullets
        self.tableRows = tableRows
        self.cards = cards
        self.code = code
        self.sequence = sequence


# Expected units are those of md2pptx
class Rectangle:
    def __init__(self, top, left, height, width):
        self.top = top
        self.left = left
        self.height = height
        self.width = width


# Note: Options stored with lower case keys
class ProcessingOptions:
    def __init__(self):
        self.defaultOptions = {}
        self.presentationOptions = {}
        self.currentOptions = {}
        self.hideMetadataStyle = False

    def getDefaultOption(self, optionName):
        return self.defaultOptions[optionName.lower()]

    def setDefaultOption(self, optionName, value):
        self.defaultOptions[optionName.lower()] = value

    def getPresentationOption(self, optionName):
        return self.presentationOptions[optionName.lower()]

    def setPresentationOption(self, optionName, value):
        self.presentationOptions[optionName.lower()] = value

    def getCurrentOption(self, optionName):
        return self.currentOptions[optionName.lower()][-1]

    # Note: Can't pop to an empty stack. Will always have default available
    def popCurrentOption(self, optionName):
        key = optionName.lower()
        if len(self.currentOptions[key]) > 1:
            # Have a non-default value to use
            self.currentOptions[key].pop()

    def setCurrentOption(self, optionName, value):
        key = optionName.lower()

        if key in self.currentOptions:
            # Add new value to existing stack
            self.currentOptions[key].append(value)
        else:
            # Start a new stack for this option
            self.currentOptions[key] = [value]

    def setOptionValues(self, optionName, value):
        key = optionName.lower()
        if key not in self.defaultOptions:
            self.setDefaultOption(optionName, value)

        self.setPresentationOption(optionName, value)

        self.setCurrentOption(optionName, value)

    def setOptionValuesArray(self, optionArray):
        for keyValuePair in optionArray:
            self.setOptionValues(keyValuePair[0], keyValuePair[1])

    def dynamicallySetOption(self, optionName, optionValue, conversion):
        lowerName = optionName.lower()
        if optionValue == "default":
            self.setCurrentOption(lowerName, self.getDefaultOption(lowerName))

        elif optionValue == "pres":
            self.setCurrentOption(lowerName, self.getPresentationOption(lowerName))

        elif optionValue in ["pop", "prev"]:
            self.popCurrentOption(lowerName)

        elif conversion == "":
            self.setCurrentOption(lowerName, optionValue)

        elif conversion == "float":
            self.setCurrentOption(lowerName, float(optionValue))

        elif conversion == "sortednumericlist":
            self.setCurrentOption(lowerName, sortedNumericList(optionValue))

        elif conversion == "int":
            self.setCurrentOption(lowerName, int(optionValue))


def startswithOneOf(haystack, needleList):
    for needle in needleList:
        if haystack.startswith(needle):
            return True

    return False


# Splits a string into words, converting each word to an integer. Returns them as a
# sorted list
def sortedNumericList(string):
    return sorted(list(map(int, set(string.split()))))


def parseRGB(str):
    if RGBmatch := RGBRegex.match(str):
        # Matches
        return (True, RGBmatch.group(1))
    else:
        return (False, "")


# Resolve symbols and unescape any numeric character references
def resolveSymbols(text):
    h = html.parser.HTMLParser()

    textSplit = re.split("(&\#x?[0-9a-f]{2,6};)", text, flags=re.IGNORECASE)
    text2 = ""
    for t in textSplit:
        if t == "":
            text2 = text2 + t
        elif (t[0:2] == "&#") & (t[-1] == ";"):
            text2 = text2 + html.unescape(t)
        else:
            text2 = text2 + t

    # Replace certain entity references with actual characters
    text2 = text2.replace("&equals;", "=")
    text2 = text2.replace("&lt;", chr(236))
    text2 = text2.replace("&gt;", chr(237))
    text2 = text2.replace("&le;", "≤")
    text2 = text2.replace("&ge;", "≥")
    text2 = text2.replace("&asymp;", "≈")
    text2 = text2.replace("&Delta;", "Δ")
    text2 = text2.replace("&delta;", "δ")
    text2 = text2.replace("&sim;", "∼")
    text2 = text2.replace("&semi;", ";")
    text2 = text2.replace("&colon;", ":")
    text2 = text2.replace("&comma;", ",")
    text2 = text2.replace("&amp;", "&")
    text2 = text2.replace("&larr;", "←")
    text2 = text2.replace("&rarr;", "→")
    text2 = text2.replace("&uarr;", "↑")
    text2 = text2.replace("&darr;", "↓")
    text2 = text2.replace("&harr;", "↔")
    text2 = text2.replace("&varr;", "↕")
    text2 = text2.replace("&nwarr;", "↖")
    text2 = text2.replace("&nearr;", "↗")
    text2 = text2.replace("&swarr;", "↙")
    text2 = text2.replace("&searr;", "↘")
    text2 = text2.replace("&lsqb;", "\[")
    text2 = text2.replace("&rsqb;", "\]")
    text2 = text2.replace("&infin;", "∞")
    text2 = text2.replace("&auml;", "ä")
    text2 = text2.replace("&Auml;", "Ä")
    text2 = text2.replace("&uuml;", "ü")
    text2 = text2.replace("&Uuml;", "Ü")
    text2 = text2.replace("&ouml;", "ö")
    text2 = text2.replace("&Ouml;", "Ö")
    text2 = text2.replace("&szlig;", "ß")
    text2 = text2.replace("&euro;", "€")
    text2 = text2.replace("&check;", "✓")
    text2 = text2.replace("&hellip;", "…")
    text2 = text2.replace("&times;", "×")
    text2 = text2.replace("&percnt;", "%")
    text2 = text2.replace("&divide;", "÷")
    text2 = text2.replace("&forall;", "∀")
    text2 = text2.replace("&exist;", "∃")
    text2 = text2.replace("&lambda;", "λ")
    text2 = text2.replace("&mu;", "μ")
    text2 = text2.replace("&nu;", "ν")
    text2 = text2.replace("&pi;", "π")
    text2 = text2.replace("&rho;", "ρ")

    return text2


def _applyCellBorderStyling(
    tcPr, linePosition, lineWidthMultiplier=1, lineCount=1, lineColour="000000"
):
    # How wide, relatively speaking to make the lines
    lineWidth = int(12700 * lineWidthMultiplier)

    # Whether the line should be single or double
    if lineCount == 2:
        lineCountValue = "dbl"
    else:
        lineCountValue = "sng"

    if linePosition == "l":
        elementName = "a:lnL"
    elif linePosition == "r":
        elementName = "a:lnR"
    elif linePosition == "t":
        elementName = "a:lnT"
    else:
        elementName = "a:lnB"

    lnX = OxmlElement(elementName)

    lnX.attrib.update(
        {"w": str(lineWidth), "cap": "flat", "cmpd": lineCountValue, "algn": "ctr"}
    )

    solidFill = OxmlElement("a:solidFill")
    srgbClr = OxmlElement("a:srgbClr")
    srgbClr.attrib.update({"val": lineColour})

    solidFill.append(srgbClr)
    lnX.append(solidFill)

    tcPr.append(lnX)


def applyCellBorderStyling(
    cell, cellBorderStyling, lineWidthMultiplier, lineCount, lineColour
):
    if cellBorderStyling == "":
        # No cell border styling required
        return

    # Get any existing cell properties element - or make one
    tc = cell._tc
    tcPr = tc.get_or_add_tcPr()

    # Draw any cell borders. More than one might apply
    if cellBorderStyling.find("l") > -1:
        _applyCellBorderStyling(tcPr, "l", lineWidthMultiplier, lineCount, lineColour)
    if cellBorderStyling.find("r") > -1:
        _applyCellBorderStyling(tcPr, "r", lineWidthMultiplier, lineCount, lineColour)
    if cellBorderStyling.find("t") > -1:
        _applyCellBorderStyling(tcPr, "t", lineWidthMultiplier, lineCount, lineColour)
    if cellBorderStyling.find("b") > -1:
        _applyCellBorderStyling(tcPr, "b", lineWidthMultiplier, lineCount, lineColour)


# Apply table line styling
def applyTableLineStyling(
    table,
    processingOptions,
):
    wholeTableLineStyling = processingOptions.getCurrentOption("addTableLines")
    linedColumns = processingOptions.getCurrentOption("addTableColumnLines")
    linedRows = processingOptions.getCurrentOption("addTableRowLines")

    lastRow = len(table.rows) - 1

    # Create blank cell styling matrix
    cellStyling = []
    for rowNumber, row in enumerate(table.rows):
        rowStyling = []
        for cell in row.cells:
            rowStyling.append("")
        cellStyling.append(rowStyling)

    # apply any "whole table" styling - from addTableLines
    if wholeTableLineStyling == "box":
        # Line around the table
        for rowNumber, row in enumerate(table.rows):
            # Figure out whether row is top, middle, or bottom
            if rowNumber == 0:
                rowStyling = "t"
            elif rowNumber == lastRow:
                rowStyling = "b"
            else:
                rowStyling = ""

            lastColumn = len(row.cells) - 1

            for columnNumber, cell in enumerate(row.cells):
                if columnNumber == 0:
                    columnStyling = "l"
                elif columnNumber == lastColumn:
                    columnStyling = "r"
                else:
                    columnStyling = ""
                cellStyling[rowNumber][columnNumber] = rowStyling + columnStyling

    elif wholeTableLineStyling == "all":
        # All edges of all cells have lines
        for rowNumber, row in enumerate(table.rows):
            lastColumn = len(row.cells) - 1

            for columnNumber, cell in enumerate(row.cells):
                cellStyling[rowNumber][columnNumber] = "tlbr"

    # Apply any row styling - from addTableColumnLines
    for rowNumber, row in enumerate(table.rows):
        if rowNumber + 1 in linedRows:
            # Line after this row so below
            for columnNumber, cell in enumerate(row.cells):
                cellStyling[rowNumber][columnNumber] = (
                    cellStyling[rowNumber][columnNumber] + "b"
                )

        elif rowNumber in linedRows:
            # Line before this row so above
            for columnNumber, cell in enumerate(row.cells):
                cellStyling[rowNumber][columnNumber] = (
                    cellStyling[rowNumber][columnNumber] + "t"
                )

    # Apply any column styling - from addTableRowLines
    for rowNumber, row in enumerate(table.rows):
        for columnNumber, cell in enumerate(row.cells):
            if columnNumber + 1 in linedColumns:
                # Line after this column so to right
                cellStyling[rowNumber][columnNumber] = (
                    cellStyling[rowNumber][columnNumber] + "r"
                )

            elif columnNumber + 1 in linedColumns:
                # Line after this column so to left
                cellStyling[rowNumber][columnNumber] = (
                    cellStyling[rowNumber][columnNumber] + "r"
                )

    # Apply the styling from the matrix to all cells
    for rowNumber, row in enumerate(table.rows):
        for columnNumber, cell in enumerate(row.cells):
            applyCellBorderStyling(
                cell,
                cellStyling[rowNumber][columnNumber],
                processingOptions.getCurrentOption("addTableLineWidth"),
                processingOptions.getCurrentOption("addTableLineCount"),
                processingOptions.getCurrentOption("addTableLineColour"),
            )


def handleSpanClass(run, className):
    if className in bgcolors:
        run = set_highlight(run, bgcolors[className])

    if className in fgcolors:
        font = run.font
        font.color.rgb = RGBColor.from_string(fgcolors[className])

    if className in emphases:
        if " bold " in " " + emphases[className] + " ":
            font.bold = True
        else:
            font.bold = False
        if " italic " in " " + emphases[className] + " ":
            font.italic = True
        else:
            font.italic = False
        if " underline " in " " + emphases[className] + " ":
            font.underline = True
        else:
            font.underline = False


def handleSpanStyle(run, styleText):
    styleElements = styleText.split(";")

    # Handle the non-empty ones - as the empty one is after the final semicolon
    for styleElement in list(filter(lambda e: e != "", styleElements)):
        styleElementSplit = styleElement.split(":")
        styleElementName = styleElementSplit[0].strip()
        styleElementValue = styleElementSplit[1].strip()

        if styleElementName == "color":
            check, RGBstring = parseRGB(styleElementValue)
            if check:
                run.font.color.rgb = RGBColor.from_string(RGBstring)
            else:
                print(f"Invalid {styleElementName} RGB value {styleElementValue}")

        elif styleElementName == "background-color":
            check, RGBstring = parseRGB(styleElementValue)
            if check:
                set_highlight(run, RGBstring)
            else:
                print(f"Invalid {styleElementName} RGB value {styleElementValue}")

        elif styleElementName == "text-decoration":
            if styleElementValue == "underline":
                run.font.underline = True

        elif styleElementName == "font-weight":
            if styleElementValue == "bold":
                run.font.bold = True

        elif styleElementName == "font-style":
            if styleElementValue == "italic":
                run.font.italic = True


def reportSlideTitle(slideNumber, indent, titleText):
    print(str(slideNumber).rjust(4) + " " + ("  " * indent) + titleText)


def reportGraphicFileNames(leftFilename, rightFilename=""):
    if rightFilename == "":
        print("             ---> " + leftFilename.ljust(30))
    else:
        print("             ---> " + leftFilename.ljust(30) + " , " + rightFilename)


# Given current indenting regime calculate what level the bullet / number is at
def calculateIndentationLevel(firstNonSpace, indentSpaces):
    return int(firstNonSpace / indentSpaces)


# Calculate picture dimensions given its natural height and bounds
def scalePicture(maxPicWidth, maxPicHeight, imageWidth, imageHeight):
    heightIfWidthUsed = maxPicWidth * imageHeight / imageWidth
    widthIfHeightUsed = maxPicHeight * imageWidth / imageHeight

    if heightIfWidthUsed > maxPicHeight:
        # Use the height to scale
        usingHeightToScale = True

        picWidth = widthIfHeightUsed
        picHeight = maxPicHeight

    else:
        # Use the width to scale
        usingHeightToScale = False

        picWidth = maxPicWidth
        picHeight = heightIfWidthUsed
    return (picWidth, picHeight, usingHeightToScale)


# Send a shape to the back on a slide
def sendToBack(shapes, shape):
    firstShapeElement = shapes[0]._element
    firstShapeElement.addprevious(shape._element)


# Turn a paragraph into a numbered inList item
def makeNumberedListItem(p):
    if (
        p._element.getchildren()[0].tag
        == "{http://schemas.openxmlformats.org/drawingml/2006/main}pPr"
    ):
        pPr = p._element.getchildren()[0]
        if len(pPr.getchildren()) > 0:
            # Remove Default Text Run Properties element - if present
            x = pPr.getchildren()[0]
            if x.tag == "{http://schemas.openxmlformats.org/drawingml/2006/main}defRPr":
                pPr.remove(x)
    else:
        pPr = OxmlElement("a:pPr")
        p._element.insert(0, pPr)

    buFont = OxmlElement("a:buFont")
    buFont.set("typeface", "+mj-lt")
    pPr.append(buFont)

    buAutoNum = OxmlElement("a:buAutoNum")
    buAutoNum.set("type", "arabicPeriod")
    pPr.append(buAutoNum)


# Add a drop shadow to a shape
def createShadow(shape):
    spPr = shape.fill._xPr

    el = OxmlElement("a:effectLst")
    spPr.append(el)

    outerShdw = OxmlElement("a:outerShdw")
    outerShdw.set("algn", "tl")
    outerShdw.set("blurRad", "50800")
    outerShdw.set("dir", "2700000")
    outerShdw.set("dist", "95250")
    outerShdw.set("rotWithShape", "0")

    el.append(outerShdw)

    prstClr = OxmlElement("a:prstClr")
    prstClr.set("val", "black")

    outerShdw.append(prstClr)

    alpha = OxmlElement("a:alpha")
    alpha.set("val", "40000")

    prstClr.append(alpha)


# Clone a shape in a slide and return the new shape.
# (This is a deep copy so the new shape will have the same
# eg bullet style as the source shape)
def addClonedShape(slide, shape1):
    # Clone the element for the shape
    el1 = shape1.element
    el2 = copy.deepcopy(el1)

    # Insert the cloned element into the shape tree
    slide.shapes._spTree.insert_element_before(el2, "p:extLst")

    # Return the shape associated with this new element
    return slide.shapes[-1]


def parseThemeColour(value):
    value2 = value.upper()
    if value2 == "NONE":
        return MSO_THEME_COLOR.NOT_THEME_COLOR
    elif value2 == "ACCENT 1":
        return MSO_THEME_COLOR.ACCENT_1
    elif value2 == "ACCENT 2":
        return MSO_THEME_COLOR.ACCENT_2
    elif value2 == "ACCENT 3":
        return MSO_THEME_COLOR.ACCENT_3
    elif value2 == "ACCENT 4":
        return MSO_THEME_COLOR.ACCENT_4
    elif value2 == "ACCENT 5":
        return MSO_THEME_COLOR.ACCENT_5
    elif value2 == "ACCENT 6":
        return MSO_THEME_COLOR.ACCENT_6
    elif value2 == "BACKGROUND 1":
        return MSO_THEME_COLOR.BACKGROUND_1
    elif value2 == "BACKGROUND 2":
        return MSO_THEME_COLOR.BACKGROUND_2
    elif value2 == "DARK 1":
        return MSO_THEME_COLOR.DARK_1
    elif value2 == "DARK 2":
        return MSO_THEME_COLOR.DARK_2
    elif value2 == "FOLLOWED HYPERLINK":
        return MSO_THEME_COLOR.FOLLOWED_HYPERLINK
    elif value2 == "HYPERLINK":
        return MSO_THEME_COLOR.HYPERLINK
    elif value2 == "LIGHT 1":
        return MSO_THEME_COLOR.LIGHT_1
    elif value2 == "LIGHT 2":
        return MSO_THEME_COLOR.LIGHT_2
    elif value2 == "TEXT 1":
        return MSO_THEME_COLOR.TEXT_1
    elif value2 == "TEXT 2":
        return MSO_THEME_COLOR.TEXT_2
    elif value2 == "MIXED":
        return MSO_THEME_COLOR.MIXED


# Following functions are workarounds for python-pptx not having these functions for the font object
def set_subscript(font):
    if font.size < Pt(24):
        font._element.set("baseline", "-50000")
    else:
        font._element.set("baseline", "-25000")


def set_superscript(font):
    if font.size < Pt(24):
        font._element.set("baseline", "60000")
    else:
        font._element.set("baseline", "30000")


def set_strikethrough(font):
    font._element.set("strike", "sngStrike")


def set_highlight(run, color):
    # get run properties
    rPr = run._r.get_or_add_rPr()

    # Create highlight element
    hl = OxmlElement("a:highlight")

    # Create specify RGB Colour element with color specified
    srgbClr = OxmlElement("a:srgbClr")
    setattr(srgbClr, "val", color)

    # Add colour specification to highlight element
    hl.append(srgbClr)

    # Add highlight element to run properties
    rPr.append(hl)

    return run


def removeBullet(paragraph):
    pPr = paragraph._p.get_or_add_pPr()
    pPr.insert(
        0,
        etree.Element("{http://schemas.openxmlformats.org/drawingml/2006/main}buNone"),
    )


def removeBullets(textFrame):
    for p in textFrame.paragraphs:
        removeBullet(p)


# Get the slide object the run is in
def SlideFromRun(run):
    return run._parent._parent._parent._parent._parent


# Get the slide object the picture is in
def SlideFromPicture(picture):
    return picture._parent._parent


# Creates a hyperlink to another slide and/or a tooltip - for a
# text run
# Note: To get just a tooltip make to_slide be the source slide
#       so it links to itself.
def createRunHyperlinkOrTooltip(run, to_slide, tooltipText=""):
    # Get hold of the shape the run is in
    if run._parent._parent._parent.__class__.__name__ == "_Cell":
        # Run in a table cell has to be handled differently
        shape = (
            run._parent._parent._parent._parent._parent._parent._parent._graphic_frame
        )
    else:
        # Ordinary text run
        shape = run._parent._parent._parent

    if to_slide == None:
        to_slide = SlideFromRun(run)
    hl = run.hyperlink
    sca = shape.click_action
    sca_hl = sca.hyperlink

    # Add a click action to generate an internal hyperlink address
    sca.target_slide = to_slide

    # Use that internal hyperlink address for the run
    hl.address = sca_hl.address

    # Also clone the hyperlink click action
    hl._hlinkClick.action = sca_hl._hlink.action
    if tooltipText != "":
        hl._hlinkClick.set("tooltip", tooltipText)

    # Also clone the hyperlink rId
    hl._hlinkClick.rId = sca_hl._hlink.rId

    # Delete the shape click action
    sca.target_slide = None


# Creates a hyperlink to another slide or a URL and/or a tooltip - for a
# picture
# Note: To get just a tooltip make to_slide be the source slide
#       so it links to itself.
def createPictureHyperlinkOrTooltip(picture, target, tooltipText=""):
    if target == None:
        # If neither a tooltip nor a target slide then return having
        # done nothing
        if tooltipText == "":
            return

        # Tooltip but no target slide
        target = SlideFromPicture(picture)
        picture.click_action.target_slide = target
    elif target.__class__.__name__ == "str":
        # Is a URL
        picture.click_action.hyperlink.address = target
    else:
        picture.click_action.target_slide = target

    if tooltipText != "":
        picture.click_action.hyperlink._hlink.set("tooltip", tooltipText)


# If a tooltip has been set return it else return an empty string
def getPictureTooltip(picture):
    if picture.click_action.hyperlink._hlink != None:
        # There is a tooltip
        return picture.click_action.hyperlink._hlink.get("tooltip")
    else:
        # There is no tooltip
        return ""


# Create hyperlink and optional tooltip from a shape eg Chevron
def createShapeHyperlinkAndTooltip(shape, to_slide, tooltipText=""):
    shape.click_action.target_slide = to_slide
    hl = shape.click_action.hyperlink
    hl._hlink.set("tooltip", tooltipText)


def get_image_size(fname):
    """Determine the image type of fhandle and return its size.
    from draco"""
    try:
        with open(fname, "rb") as fhandle:
            head = fhandle.read(24)
            if len(head) != 24:
                return -1, -1
            if imghdr.what(fname) == "png":
                check = struct.unpack(">i", head[4:8])[0]
                if check != 0x0D0A1A0A:
                    return
                width, height = struct.unpack(">ii", head[16:24])
            elif imghdr.what(fname) == "gif":
                width, height = struct.unpack("<HH", head[6:10])
            elif imghdr.what(fname) == "jpeg":
                try:
                    fhandle.seek(0)  # Read 0xff next
                    size = 2
                    ftype = 0
                    while not 0xC0 <= ftype <= 0xCF:
                        fhandle.seek(size, 1)
                        byte = fhandle.read(1)
                        while ord(byte) == 0xFF:
                            byte = fhandle.read(1)
                        ftype = ord(byte)
                        size = struct.unpack(">H", fhandle.read(2))[0] - 2
                    # We are at a SOFn block
                    fhandle.seek(1, 1)  # Skip 'precision' byte.
                    height, width = struct.unpack(">HH", fhandle.read(4))
                except Exception:  # IGNORE:W0703
                    return
            else:
                return
            return width, height
    except EnvironmentError:
        return -1, -1


# Render a list of bullets
def renderText(shape, bullets):
    baseTextDecrement = processingOptions.getCurrentOption("baseTextDecrement")
    baseTextSize = processingOptions.getCurrentOption("baseTextSize")

    tf = shape.text_frame

    for bulletNumber, bullet in enumerate(bullets):
        para0 = tf.paragraphs[0]

        if bulletNumber == 0:
            # Don't need to create paragraph
            p = para0
        else:
            # We need a new paragraph
            p = tf.add_paragraph()

        # Set the paragraph's level - zero-indexed
        p.level = int(bullet[0])

        # Set the paragraph's font size, adjusted for level, if necessary
        if baseTextSize > 0:
            p.font.size = Pt(baseTextSize - p.level * baseTextDecrement)

        addFormattedText(p, bullet[1])

        if bullet[2] == "numbered":
            makeNumberedListItem(p)

    tf.auto_size = MSO_AUTO_SIZE.TEXT_TO_FIT_SHAPE


# Render an array of table rows
def renderTable(shape, bounds, tableRows):
    x = 1


def findTitleShape(slide):
    if slide.shapes.title == None:
        # Have to use first shape as title
        return slide.shapes[0]
    else:
        return slide.shapes.title


def findBodyShape(slide):
    if len(slide.shapes) > 1:
        return slide.shapes[1]
    elif slide.shapes.title == None:
        return slide.shapes[0]
    else:
        return None


# Returns a top, left, width, height for content to be rendered into
def getContentRect(presentation, slide, topOfContent, margin):
    numbersHeight = processingOptions.getCurrentOption("numbersHeight")
    # Left and right are always defined by the margins
    rectLeft = margin
    rectWidth = presentation.slide_width - 2 * margin
    if topOfContent == 0:
        # There is no title on this slide
        rectTop = margin
        rectHeight = presentation.slide_height - margin - max(margin, numbersHeight)
    else:
        # There is a title on this slide
        rectTop = topOfContent + margin
        rectHeight = presentation.slide_height - rectTop - max(margin, numbersHeight)

    return (rectLeft, rectWidth, rectTop, rectHeight)


# Finds the title and adds the text to it, returning title bottom, title shape, and
# flattened title
def formatTitle(presentation, slide, titleText, titleFontSize):
    marginBase = processingOptions.getCurrentOption("marginBase")

    # Find title
    title = findTitleShape(slide)

    if titleText == "&nbsp;":
        deleteSimpleShape(title)

        return (marginBase, None, "<No title>")

    if processingOptions.getCurrentOption("adjustTitles"):
        title.top = marginBase
        title.left = marginBase
        title.width = presentation.slide_width - marginBase * 2

    # Figure out how many lines title will need (ignoring overflow)
    titleLineCount = len(titleText.split("<br/>"))

    # Add the title text to the first paragraph
    flattenedTitle = addFormattedText(title.text_frame.paragraphs[0], titleText)

    if processingOptions.getCurrentOption("adjustTitles"):
        title.height = Pt(titleFontSize) * titleLineCount

    title.text_frame.paragraphs[0].font.size = Pt(titleFontSize)
    title.text_frame.vertical_anchor = MSO_ANCHOR.TOP

    # Return where the next shape below the title would be - vertically
    return (title.top + title.height + Inches(0.1), title, flattenedTitle)


# Parse the string after the e.g. ### for a displayable title and
# an optional heading reference
def parseTitleText(titleLineString):
    # Get rid of any cruft on the line
    slideTitleWithPossibleHref = titleLineString.strip().rstrip("#").rstrip()

    if hrefMatch := slideHrefRegex.match(slideTitleWithPossibleHref):
        # Use the explicit href
        slideTitle = hrefMatch.group(1)
        href = hrefMatch.group(2)
    else:
        # No href
        href = ""
        slideTitle = slideTitleWithPossibleHref

    return slideTitle, href


def parseText(text):
    textArray = []
    state = "N"
    fragment = ""
    lastChar = ""
    spanState = "None"

    # Replace any "\#" strings with entity reference
    text2 = text.replace("\\#", "&#x23;")

    # Replace any "<br/>" strings with newline single character
    text2 = text2.replace("<br/>", "\n")

    # Replace any escaped asterisk strings with entity reference
    text2 = text2.replace("\\*", "&lowast;")

    # Replace any asterisks with spaces either side with entity reference
    text2 = text2.replace(" * ", " &lowast; ")
    if text2[-2:] == " *":
        text2 = text2[:-2] + " &lowast;"

    # Replace any footnote reference starts with char 238
    text2 = text2.replace("[^", chr(238))

    # Replace any span style starts with char 239
    text2 = re.sub(spanStyleRegex, chr(239), text2)

    # Replace any span class starts with char 240
    text2 = re.sub(spanClassRegex, chr(240), text2)

    # Replace any span ends with char 241
    text2 = text2.replace("</span>", chr(241))

    # Replace any abbreviation starts with char 242
    text2 = text2.replace("<abbr title=", chr(242))

    # Replace any abbreviation ends with char 243
    text2 = text2.replace("</abbr>", chr(243))

    # Replace any \[ with char 244
    text2 = text2.replace("\[", chr(244))

    # Replace any \] with char 245
    text2 = text2.replace("\]", chr(245))

    # 246 is link separator special character. See below

    # Replace any {~~ with char 247
    text2 = text2.replace("{~~", chr(247))

    # Replace any ~~} with char 247
    text2 = text2.replace("~~}", chr(247))

    # Replace any {== with char 248
    text2 = text2.replace("{==", chr(248))

    # Replace any ==} with char 248
    text2 = text2.replace("==}", chr(248))

    # Replace any {>> with char 249
    text2 = text2.replace("{>>", chr(249))

    # Replace any <<} with char 249
    text2 = text2.replace("<<}", chr(249))

    # Replace any {-- with char 250
    text2 = text2.replace("{--", chr(250))

    # Replace any --} with char 250
    text2 = text2.replace("--}", chr(250))

    # Replace any {++ with char 251
    text2 = text2.replace("{++", chr(251))

    # Replace any ++} with char 251
    text2 = text2.replace("++}", chr(251))

    # Replace any <ins> with char 252
    text2 = text2.replace("<ins>", chr(252))

    # Replace any </ins> with char 252
    text2 = text2.replace("</ins>", chr(252))

    # Replace any <del> with char 253
    text2 = text2.replace("<del>", chr(253))

    # Replace any </del> with char 253
    text2 = text2.replace("</del>", chr(253))

    # Replace any <sub> with char 254
    text2 = text2.replace("<sub>", chr(254))

    # Replace any </sub> with char 254
    text2 = text2.replace("</sub>", chr(254))

    # Replace any <sup> with char 255
    text2 = text2.replace("<sup>", chr(255))

    # Replace any </sup> with char 255
    text2 = text2.replace("</sup>", chr(255))

    # Handle escaped underscore
    text2 = text2.replace("\_", "_")

    # Unescape any numeric character references
    text3 = resolveSymbols(text2)

    for c in text3:
        if c == "*":
            # Changing state
            if state == "N":
                # First * potentially starts italic
                textArray.append([state, fragment])
                fragment = ""
                state = "I"

            elif state == "I":
                # Either go to bold or end italic
                if lastChar == "*":
                    # Go to bold
                    state = "B1"

                else:
                    # End italic
                    textArray.append([state, fragment])
                    fragment = ""
                    state = "N"

            elif state == "B1":
                # Starting to close bold bracket
                state = "B2"

            elif lastChar == "*":
                # closing either bold or italic bracket
                textArray.append([state, fragment])
                fragment = ""
                state = "N"

        elif c == "`":
            if state == "N":
                # Going to code
                textArray.append([state, fragment])
                fragment = ""
                state = "C"

            else:
                # exiting code
                textArray.append([state, fragment])
                fragment = ""
                state = "N"

        elif ord(c) == 247:
            # Entering or leaving CriticMarkup replacement
            if state == "N":
                # Going to CriticMarkup replacement
                textArray.append([state, fragment])
                fragment = ""
                state = "CMRep"

            else:
                # exiting CriticMarkup replacement
                textArray.append([state, fragment])
                fragment = ""
                state = "N"

        elif ord(c) == 248:
            # Entering or leaving CriticMarkup highlight
            if state == "N":
                # Going to CriticMarkup highlight
                textArray.append([state, fragment])
                fragment = ""
                state = "CMHig"

            else:
                # exiting CriticMarkup highlight
                textArray.append([state, fragment])
                fragment = ""
                state = "N"

        elif ord(c) == 249:
            # Entering or leaving CriticMarkup comment
            if state == "N":
                # Going to CriticMarkup comment
                textArray.append([state, fragment])
                fragment = ""
                state = "CMCom"

            else:
                # exiting CriticMarkup comment
                textArray.append([state, fragment])
                fragment = ""
                state = "N"

        elif ord(c) == 250:
            # Entering or leaving CriticMarkup deletion
            if state == "N":
                # Going to CriticMarkup deletion
                textArray.append([state, fragment])
                fragment = ""
                state = "CMDel"

            else:
                # exiting CriticMarkup deletion
                textArray.append([state, fragment])
                fragment = ""
                state = "N"

        elif ord(c) == 251:
            # Entering or leaving CriticMarkup addition
            if state == "N":
                # Going to CriticMarkup addition
                textArray.append([state, fragment])
                fragment = ""
                state = "CMAdd"

            else:
                # exiting CriticMarkup addition
                textArray.append([state, fragment])
                fragment = ""
                state = "N"

        elif ord(c) == 252:
            # Entering or leaving underline
            if state == "N":
                # Going to underline
                textArray.append([state, fragment])
                fragment = ""
                state = "Ins"

            else:
                # exiting underline
                textArray.append([state, fragment])
                fragment = ""
                state = "N"

        elif ord(c) == 253:
            # Entering or leaving strikethrough
            if state == "N":
                # Going to strikethrough
                textArray.append([state, fragment])
                fragment = ""
                state = "Del"

            else:
                # exiting strikethrough
                textArray.append([state, fragment])
                fragment = ""
                state = "N"
        elif ord(c) == 254:
            # Entering or leaving subscript
            if state == "N":
                # Going to subscript
                textArray.append([state, fragment])
                fragment = ""
                state = "Sub"

            else:
                # exiting subscript
                textArray.append([state, fragment])
                fragment = ""
                state = "N"

        elif ord(c) == 255:
            # Entering or leaving superscript
            if state == "N":
                # Going to superscript
                textArray.append([state, fragment])
                fragment = ""
                state = "Sup"

            else:
                # exiting superscript
                textArray.append([state, fragment])
                fragment = ""
                state = "N"

        elif c == "[":
            if state == "N":
                # Could be entering a Link
                if fragment != "":
                    textArray.append([state, fragment])

                # The bracket is kept in in case there is no matching ]
                fragment = "["
                state = "LinkText1"

        elif c == "]":
            # Could be ending picking up the link text
            if state == "LinkText1":
                # Picked up end of link text
                state = "LinkText2"

                # Remove [ and add a separator to allow for link URL
                fragment = fragment[1:] + chr(246)

            elif state == "fnref":
                # This terminates a footnote reference
                textArray.append([state, fragment])
                state = "N"
                fragment = ""

            else:
                # This was an ordinary square bracket
                fragment += "]"

        elif c == "(":
            # Could be starting to pick up the link URL
            if state == "LinkText2":
                # Picked up start of link URL
                state = "LinkURL1"
            else:
                fragment = fragment + c

        elif c == ")":
            # Could be ending picking up the link URL
            if state == "LinkURL1":
                # Picked up end of link URL
                textArray.append(["Link", fragment])
                fragment = ""
                state = "N"
            else:
                fragment = fragment + c

        elif ord(c) == 236:
            fragment = fragment + "<"

        elif ord(c) == 244:
            fragment = fragment + "["

        elif ord(c) == 245:
            fragment = fragment + "]"

        elif ord(c) == 242:
            if fragment != "":
                textArray.append([state, fragment])
                fragment = ""
            dictEntry = ""

        elif ord(c) == 243:
            dictEntry = fragment.split(">")
            dictAbbrev = dictEntry[1]
            dictFull = dictEntry[0].strip().strip("'").strip('"')
            abbrevDictionary[dictAbbrev] = dictFull
            textArray.append(["Gloss", dictAbbrev, dictAbbrev, dictFull])
            fragment = ""

        elif ord(c) == 241:
            # End of span
            if spanState == "Class":
                # Span with class
                splitting = fragment.split(">")
                spanText = splitting[1]
                className = splitting[0].strip().strip("'").strip('"')
                styleText = ""
                if (
                    (className in bgcolors)
                    | (className in fgcolors)
                    | (className in emphases)
                ):
                    textArray.append(["SpanClass", [className, spanText]])

                    fragment = ""

                else:
                    print(
                        f"{className} is not defined. Ignoring reference to it in <span> element."
                    )

                    fragment = spanText
            else:
                # Span with style
                splitting = fragment.split(">")
                spanText = splitting[1]
                styleText = splitting[0].strip().strip("'").strip('"')
                textArray.append(["SpanStyle", [styleText, spanText]])
                className = ""
                fragment = ""

            spanState = "None"

        elif ord(c) == 240:
            # In span element where we hit the class name
            if fragment != "":
                textArray.append([state, fragment])

                fragment = ""
            spanState = "Class"

        elif ord(c) == 239:
            # In span element where we hit the style text
            if fragment != "":
                textArray.append([state, fragment])

                fragment = ""
                spanState = "Style"
        elif ord(c) == 238:
            if fragment != "":
                textArray.append([state, fragment])

                fragment = ""
                state = "fnref"
        else:
            fragment = fragment + c

        lastChar = c

    if fragment != "":
        textArray.append([state, fragment])
    return textArray


# Calls the tokeniser and then handles the fragments it gets back
def addFormattedText(p, text):
    boldBold = processingOptions.getCurrentOption("boldBold")
    boldColour = processingOptions.getCurrentOption("boldColour")
    italicItalic = processingOptions.getCurrentOption("italicItalic")
    italicColour = processingOptions.getCurrentOption("italicColour")
    monoFont = processingOptions.getCurrentOption("monoFont")

    # Get back parsed text fragments, along with control information on each
    # fragment
    parsedText = parseText(text)

    # Replace chr(237) with > in each Fragment
    for f in range(len(parsedText)):
        if parsedText[f][0] in ["SpanClass", "SpanStyle"]:
            parsedText[f][1][1] = parsedText[f][1][1].replace(chr(237), ">")
        else:
            parsedText[f][-1] = parsedText[f][-1].replace(chr(237), ">")

    # Prime flattened Text
    flattenedText = ""
    for fragment in parsedText:
        if fragment[0] == "Gloss":
            fragType, fragDetail, fragTerm, fragTitle = fragment
        else:
            fragType, fragDetail = fragment

        # Break into subfragments around a newline
        if fragType == "SpanClass":
            className, fragText = fragDetail
            styleText = ""
            subfragments = fragText.split("\n")
        elif fragType == "SpanStyle":
            styleText, fragText = fragDetail
            className = ""
            subfragments = fragText.split("\n")
        else:
            subfragments = fragDetail.split("\n")

        # Process each subfragment
        sfnum = 0
        for subfragment in subfragments:
            if sfnum > 0:
                # Subfragments after the first need to be preceded by a line break
                p.add_line_break()

            sfnum += 1
            # Ensure "\*" is rendered as a literal asterisk
            subfragment = subfragment.replace("&lowast;", "*")

            # Ensure "\#" is rendered as a literal octothorpe
            subfragment = subfragment.replace("&#x23;", "#")

            run = p.add_run()
            if fragType not in ["Link", "fnref", "Gloss"]:
                run.text = subfragment
            elif fragType == "Gloss":
                run.text = fragTerm

            if fragType == "I":
                font = run.font
                if italicItalic == True:
                    font.italic = True
                if italicColour != "":
                    font.color.theme_color = italicColour

            elif fragType == "Gloss":
                # Add this run to abbrevRunsDictionary - for Glossary fix ups later
                if fragTerm not in abbrevRunsDictionary:
                    abbrevRunsDictionary[fragTerm] = []
                abbrevRunsDictionary[fragTerm].append(run)
            elif fragType == "fnref":
                font = run.font
                font.size = Pt(16)
                set_superscript(font)
                fnref = fragment[1]
                if fnref in footnoteReferences:
                    footnoteNumber = footnoteReferences.index(fnref)
                    run.text = str(footnoteNumber + 1)
                    footnoteRunsDictionary[footnoteNumber] = run
                else:
                    run.text = "[?]"
                    print("Error: Footnote reference '" + fnref + "' unresolved.")
                linkText = "!"
                fragment = ""

            elif fragType == "SpanClass":
                handleSpanClass(run, className)

            elif fragType == "SpanStyle":
                handleSpanStyle(run, styleText)

            elif fragType == "B2":
                font = run.font
                if boldBold == True:
                    font.bold = True
                if boldColour != "":
                    font.color.theme_color = boldColour
            elif fragType == "C":
                font = run.font
                font.name = monoFont
            elif fragType == "CMRep":
                font = run.font
                font.color.rgb = RGBColor(255, 140, 0)
                run.text = "{~~" + subfragment + "~~}"
            elif fragType == "CMHig":
                font = run.font
                font.color.rgb = RGBColor(195, 0, 195)
                run.text = "{==" + subfragment + "==}"
            elif fragType == "CMCom":
                font = run.font
                font.color.rgb = RGBColor(0, 0, 195)
                run.text = "{>>" + subfragment + "<<}"
            elif fragType == "CMDel":
                font = run.font
                font.color.rgb = RGBColor(195, 0, 0)
                run.text = "{--" + subfragment + "--}"
            elif fragType == "CMAdd":
                font = run.font
                font.color.rgb = RGBColor(0, 195, 0)
                run.text = "{++" + subfragment + "++}"
            elif fragType == "Ins":
                font = run.font
                font.underline = True
            elif fragType == "Del":
                font = run.font
                set_strikethrough(font)
            elif fragType == "Sub":
                font = run.font
                set_subscript(font)
            elif fragType == "Sup":
                font = run.font
                set_superscript(font)
            elif fragType == "Link":
                linkArray = subfragment.split(chr(246))
                linkText = linkArray[0]
                linkURL = linkArray[1]
                run.text = linkText
                if linkURL.startswith("#"):
                    # Is an internal Url
                    linkHref = linkURL[1:].strip()
                    href_runs[linkHref] = run
                else:
                    # Not an internal link so create it
                    hlink = run.hyperlink
                    hlink.address = linkURL

            # Add the flattened text from this subfragment
            if fragType == "Link":
                flattenedText = flattenedText + linkText
            else:
                flattenedText = flattenedText + subfragment

    return flattenedText


def addFooter(presentation, slideNumber, slide):
    numbersHeight = processingOptions.getCurrentOption("numbersHeight")
    shapes = slide.shapes
    footer = shapes.add_textbox(
        Inches(0.1),
        presentation.slide_height - numbersHeight,
        Inches(0.2),
        numbersHeight / 2,
    )
    frame = footer.text_frame
    p = frame.paragraphs[0]
    run = p.add_run()
    run.text = str(slideNumber)
    font = run.font
    font.size = Pt(12)


# Called "Simple" because more complex shapes might not work
def deleteSimpleShape(shape):
    if shape == None:
        return
    shapeElement = shape.element
    shapeElement.getparent().remove(shapeElement)


def createProcessingSummarySlide(presentation, rawMetadata):
    tableMargin = processingOptions.getCurrentOption("tableMargin")
    pageTitleSize = processingOptions.getCurrentOption("pageTitleSize")
    # Use the first slide in the template presentation as the base
    slide = presentation.slides[0]

    # Delete any body shape
    deleteSimpleShape(findBodyShape(slide))

    # Build "run time" text
    now = datetime.datetime.now()
    runTime = now.strftime("%H:%M").lstrip()
    runDate = now.strftime("%e %B, %G").lstrip()
    runDateTime = "Presentation built: " + runTime + " on " + runDate

    # Format title and add title text
    slideTitleBottom, title, flattenedTitle = formatTitle(
        presentation, slide, banner + "<br/>" + runDateTime, pageTitleSize
    )

    # Work out how many pairs of columns we need
    if processingOptions.hideMetadataStyle:
        # Adjust metadata item count to remove style.
        metadata = []
        for metadataItem in rawMetadata:
            if metadataItem[0].startswith("style.") == False:
                metadata.append(metadataItem)
    else:
        metadata = rawMetadata
    
    metadataRows = len(metadata)

    maxMetadataRowsPerColumn = 15
    if metadataRows > 2 * maxMetadataRowsPerColumn:
        metadataColumnPairs = 3
    elif metadataRows > maxMetadataRowsPerColumn:
        metadataColumnPairs = 2
    else:
        metadataColumnPairs = 1

    columns = metadataColumnPairs * 2
    rows = min(maxMetadataRowsPerColumn, metadataRows)

    # Get the rectangle the content will draw in
    contentLeft, contentWidth, contentTop, contentHeight = getContentRect(
        presentation, slide, slideTitleBottom, tableMargin
    )

    tableHeight = min(contentHeight, Inches(0.25) * rows)

    # Figure out the width of a single-width column
    columnWidthUnit = int(contentWidth / (2 * metadataColumnPairs))

    # Create the table with the above number of rows and columns
    newTable = slide.shapes.add_table(
        rows, columns, tableMargin, contentTop, contentWidth, tableHeight
    ).table

    # Don't want headings
    newTable.first_row = False

    cols = newTable.columns
    for cp in range(metadataColumnPairs):
        cols[2 * cp].width = columnWidthUnit
        cols[2 * cp + 1].width = columnWidthUnit

    row = 0
    column = 0
    for item in metadata:
        key, value = item

        if row == maxMetadataRowsPerColumn:
            # Move to next column
            column += 2
            row = 0
        newTable.cell(row, column).text = key
        newTable.cell(row, column + 1).text = value
        if metadataColumnPairs == 3:
            newTable.cell(row, column).text_frame.paragraphs[0].font.size = Pt(12)
            newTable.cell(row, column + 1).text_frame.paragraphs[0].font.size = Pt(12)
        elif metadataColumnPairs == 2:
            newTable.cell(row, column).text_frame.paragraphs[0].font.size = Pt(14)
            newTable.cell(row, column + 1).text_frame.paragraphs[0].font.size = Pt(14)
        else:
            newTable.cell(row, column).text_frame.paragraphs[0].font.size = Pt(16)
            newTable.cell(row, column + 1).text_frame.paragraphs[0].font.size = Pt(16)
        row += 1


# Note: This doesn't use formatTitle()
def createTitleOrSectionSlide(
    presentation,
    slideNumber,
    titleText,
    layout,
    titleSize,
    subtitleText,
    subtitleSize,
    notes_text,
):
    marginBase = processingOptions.getCurrentOption("marginBase")

    slide = presentation.slides.add_slide(presentation.slide_layouts[layout])

    # Add title
    title = findTitleShape(slide)
    flattenedTitle = addFormattedText(title.text_frame.paragraphs[0], titleText)

    title.text_frame.paragraphs[0].font.size = Pt(titleSize)

    # Add subtitle - if there is one
    if (subtitleText.strip() != "") & (subtitleText[0:2] != "\n\n"):
        # There is a subtitle
        chunks = subtitleText.strip().split("\n\n")
        subtitleText = chunks[0]
        notes_text = "\n\n".join(chunks[1:])
        createSlideNotes(slide, notes_text)

        subtitleShape = findBodyShape(slide)
        if subtitleShape != None:
            addFormattedText(subtitleShape.text_frame.paragraphs[0], subtitleText)
            subtitleShape.text_frame.paragraphs[0].font.size = Pt(subtitleSize)
        else:
            print("Warning: No subtitle shape on this slide to add text to.")
    else:
        # Reformat subtitle shape to be out of the way
        subtitleShape = findBodyShape(slide)
        if subtitleShape != None:
            subtitleShape.top = title.top + title.height + marginBase * 2
            subtitleShape.width = title.width
            subtitleShape.left = title.left
            subtitleShape.height = marginBase * 2

    reportSlideTitle(slideNumber, 1, flattenedTitle)

    if want_numbers_headings is True:
        addFooter(presentation, slideNumber, slide)

    return slide


def handleWhateverGraphicType(graphicFilename):
    # Handles both physical file and URI file types
    if ":" in graphicFilename:
        # Is a URI - so we have to retrieve it and store it in a temporary file

        # Massage the URI into a printable filename
        if len(graphicFilename) > 50:
            printableGraphicFilename = (
                graphicFilename[:25] + "..." + graphicFilename[-25:]
            )
        else:
            printableGraphicFilename = graphicFilename

        # Retrieve the data
        operUrl = urllib.request.urlopen(graphicFilename)
        data = operUrl.read()

        # Store in a temporary file
        graphicFile = tempfile.NamedTemporaryFile(delete=False)
        graphicFile.write(data)

        if ".svg" in graphicFilename.lower():
            # is a web-based SVG file
            if have_cairosvg:
                # Convert SVG file to temporary PNG

                # Store SVG in a temporary file
                convertedGraphicFile = tempfile.NamedTemporaryFile(delete=False)

                cairosvg.svg2png(file_obj=graphicFile, write_to=convertedGraphicFile)

                # Retrieve the temporary file name
                graphicFilename = convertedGraphicFile.name

            else:
                print("Don't have CairoSVG installed. Terminating.")
                sys.exit()
        else:
            # Retrieve the temporary (PNG) file name
            graphicFilename = graphicFile.name

    else:
        # Files don't get their names edited
        printableGraphicFilename = graphicFilename

        if ".svg" in graphicFilename.lower():
            # is a physical SVG file
            if have_cairosvg:
                # Convert SVG file to temporary PNG

                # Store in a temporary file
                graphicFile = tempfile.NamedTemporaryFile(delete=False)

                cairosvg.svg2png(file_obj=open(graphicFilename), write_to=graphicFile)

                # Retrieve the temporary file name
                graphicFilename = graphicFile.name

            else:
                print("Don't have CairoSVG installed. Terminating.")
                sys.exit()

    return graphicFilename, printableGraphicFilename


def createCodeBlock(slideInfo, slide, renderingRectangle, codeBlockNumber):
    monoFont = processingOptions.getCurrentOption("monoFont")
    baseTextSize = processingOptions.getCurrentOption("baseTextSize")
    defaultBaseTextSize = processingOptions.getDefaultOption("baseTextSize")

    # A variable number of newlines appear before the actual code
    codeLines = slideInfo.code[codeBlockNumber]

    # Figure out code slide type
    if codeLines[0].startswith("<pre"):
        codeType = "pre"
    elif codeLines[0].startswith("<code"):
        codeType = "code"
    elif codeLines[0].startswith("```"):
        codeType = "backticks"
    else:
        codeType = "indented"

    # Handle any trailing empty lines
    while codeLines[-1] == "":
        codeLines.pop(-1)

    # Handle any leading <pre>, <code>, triple backtick line
    if startswithOneOf(codeLines[0], ["<pre>", "<code>", "```"]):
        codeLines.pop(0)

    # Handle any trailing </pre>, </code>, triple backtick line
    if startswithOneOf(codeLines[-1], ["</pre>", "</code>", "```"]):
        codeLines.pop(-1)

    codeBox = slide.shapes.add_textbox(
        renderingRectangle.left,
        renderingRectangle.top,
        renderingRectangle.width,
        renderingRectangle.height,
    )

    # Try to control text frame but SHAPE_TO_FIT_TEXT doesn't seem to work
    tf = codeBox.text_frame
    tf.auto_size = MSO_AUTO_SIZE.SHAPE_TO_FIT_TEXT
    tf.word_wrap = False

    # Fill the code box with background colour - whether explicit or defaulted
    fill = codeBox.fill
    fill.solid()
    fill.fore_color.rgb = RGBColor.from_string(
        processingOptions.getCurrentOption("codeBackground")
    )

    # Get the sole paragraph
    p = codeBox.text_frame.paragraphs[0]

    # Set the font size slightly smaller than usual
    if len(codeLines) >= 20:
        divisor = 1.5
    else:
        divisor = 1.2
    if baseTextSize > 0:
        p.font.size = int(Pt(baseTextSize) / divisor)
    else:
        p.font.size = int(Pt(defaultBaseTextSize) / divisor)

    # Estimate how wide the code box would need to be at the current font size
    # versus actual width
    codeColumns = processingOptions.getCurrentOption("codeColumns")
    fixedPitchHeightWidthRatio = processingOptions.getCurrentOption(
        "fixedPitchHeightWidthRatio"
    )

    estimatedWidthVersusCodeboxWidth = (
        p.font.size * codeColumns / codeBox.width / fixedPitchHeightWidthRatio
    )
    if estimatedWidthVersusCodeboxWidth > 1:
        # The code is wider so shrink the font so the code fits
        p.font.size = p.font.size / estimatedWidthVersusCodeboxWidth
    else:
        # The code is narrower so shrink the code textbox so the code just fits
        # - assuming declared width is accurate
        codeBox.width = int(p.font.size * codeColumns / fixedPitchHeightWidthRatio)

        # Center the code box - actually don't - 5 October 2021 temporary "fix"
        # codeBox.left = int((presentation.slide_width - codeBox.width) / 2)

    # Use the code foreground colour - whether explicit or defaulted
    p.font.color.rgb = RGBColor.from_string(
        processingOptions.getCurrentOption("codeforeground")
    )

    # Adjust code box height based on lines
    codeBox.height = min(
        len(codeLines) * Pt(baseTextSize + 5), renderingRectangle.height
    )

    # Add code
    if codeType == "pre":
        # span elements want special handling
        for codeLine in codeLines:
            # Resolve eg entity references
            codeLine = resolveSymbols(codeLine)

            # Split the line - and maybe there are spans
            spanFragments = codeLine.split("<span ")
            if len(spanFragments) > 1:
                textArray = []
                # Break line down into what will become runs
                for fragmentNumber, fragment in enumerate(spanFragments):
                    if fragmentNumber > 0:
                        # Find start of span class
                        fragment = "<span " + fragment
                        if spanClassMatch := spanClassRegex.match(fragment):
                            afterSpanTag = fragment[spanClassMatch.end(1) :]
                            className = afterSpanTag[7 : afterSpanTag.index(">") - 1]
                            if (
                                (className in bgcolors)
                                | (className in fgcolors)
                                | (className in emphases)
                            ):
                                afterClosingAngle = afterSpanTag[
                                    afterSpanTag.index(">") + 1 :
                                ]
                                startEnd = afterClosingAngle.index("</span>")
                                afterSpan2 = afterClosingAngle[:startEnd]
                                afterSpan3 = afterClosingAngle[startEnd + 7 :]
                                textArray.append(["SpanClass", [className, afterSpan2]])
                                textArray.append(["Normal", afterSpan3])
                                fragment = ""
                            else:
                                print(
                                    className
                                    + " is not defined. Ignoring reference to it in <span> element."
                                )
                        elif spanStyleMatch := spanStyleRegex.match(fragment):
                            afterSpanTag = fragment[spanStyleMatch.end(1) :]
                            styleText = afterSpanTag[7 : afterSpanTag.index(">") - 1]
                            styleElements = styleText.split(";")
                            afterClosingAngle = afterSpanTag[
                                afterSpanTag.index(">") + 1 :
                            ]
                            startEnd = afterClosingAngle.index("</span>")
                            afterSpan2 = afterClosingAngle[:startEnd]
                            afterSpan3 = afterClosingAngle[startEnd + 7 :]
                            textArray.append(["SpanStyle", [styleText, afterSpan2]])
                            textArray.append(["Normal", afterSpan3])
                            fragment = ""
                    else:
                        textArray.append(["Normal", fragment])

                # Now we have a text array we can add the runs for the line
                for textArrayItem in textArray:
                    textArrayItemType = textArrayItem[0]
                    if textArrayItemType == "Normal":
                        # Is not in a span element bracket
                        className = ""
                        spanStyle = ""
                        spanText = textArrayItem[1]

                    elif textArrayItemType == "SpanClass":
                        # Is in a span class element bracket
                        className = textArrayItem[1][0]
                        spanText = textArrayItem[1][1]
                        spanStyle = ""

                    else:
                        # Is in a span style element bracket
                        spanStyle = textArrayItem[1][0]
                        spanText = textArrayItem[1][1]

                    if spanText != "":
                        run = p.add_run()
                        run.text = spanText
                        font = run.font
                        font.name = monoFont

                    if className != "":
                        # Augment run with whatever the span class calls for
                        handleSpanClass(run, className)

                    if spanStyle != "":
                        # Augment the run with whatever the style calls for
                        handleSpanStyle(run, spanStyle)

                # Add terminating newline
                run = p.add_run()
                run.text = "\n"
                font = run.font
                font.name = monoFont
            else:
                # Line has no spans in
                run = p.add_run()
                run.text = codeLine + "\n"
                font = run.font
                font.name = monoFont

    else:
        # span doesn't need treating specially
        for codeLine in codeLines:
            # Resolve eg entity references
            codeLine = resolveSymbols(codeLine)

            run = p.add_run()
            run.text = codeLine + "\n"
            font = run.font
            font.name = monoFont

    return slide


def createAbstractSlide(presentation, slideNumber, titleText, paragraphs):
    titleOnlyLayout = processingOptions.getCurrentOption("titleOnlyLayout")
    marginBase = processingOptions.getCurrentOption("marginBase")
    pageTitleSize = processingOptions.getCurrentOption("pageTitleSize")

    slide = presentation.slides.add_slide(presentation.slide_layouts[titleOnlyLayout])

    shapes = slide.shapes

    # Add title and constrain its size and placement
    slideTitleBottom, title, flattenedTitle = formatTitle(
        presentation, slide, titleText, pageTitleSize
    )

    reportSlideTitle(slideNumber, 3, "Abstract: " + flattenedTitle)

    # Get the rectangle the content will draw in
    contentLeft, contentWidth, contentTop, contentHeight = getContentRect(
        presentation, slide, slideTitleBottom, marginBase
    )

    # Add abstract text
    abstractBox = slide.shapes.add_textbox(
        contentLeft,
        contentTop,
        contentWidth,
        contentHeight,
    )

    p = abstractBox.text_frame.paragraphs[0]
    tf = abstractBox.text_frame
    f = p.font
    f.size = Pt(22)
    for para, abstractParagraph in enumerate(paragraphs):
        paragraphLevel, paragraphText, paragraphType = abstractParagraph

        if para > 0:
            # Spacer paragraph
            p = tf.add_paragraph()
            f = p.font
            f.size = Pt(22)

            # Content paragraph
            p = tf.add_paragraph()
            f = p.font
            f.size = Pt(22)
        addFormattedText(p, paragraphText)

    tf.word_wrap = True

    if want_numbers_content is True:
        addFooter(presentation, slideNumber, slide)

    return slide


# Unified creation of a table or a code or a content slide
def createContentSlide(presentation, slideNumber, slideInfo):

    titleOnlyLayout = processingOptions.getCurrentOption("titleOnlyLayout")
    contentSlideLayout = processingOptions.getCurrentOption("contentSlideLayout")
    marginBase = processingOptions.getCurrentOption("marginBase")
    pageTitleSize = processingOptions.getCurrentOption("pageTitleSize")

    # slideInfo's body text is only filled in if there is code - and that's
    # where the code - plus preamble and postamble is.
    if slideInfo.code != "":
        haveCode = True
    else:
        haveCode = False

    # Create the slide and check for bullets and/or cards
    if (slideInfo.bullets == []) & (slideInfo.cards == []):
        slideLayout = titleOnlyLayout
        haveBulletsCards = False
    else:
        slideLayout = contentSlideLayout
        haveBulletsCards = True
    slide = presentation.slides.add_slide(presentation.slide_layouts[slideLayout])

    # Check for table / graphics content
    if slideInfo.tableRows == []:
        haveTableGraphics = False
    else:
        haveTableGraphics = True

    ####################################################################
    # At this point haveCode, haveBulletsCards, haveTableGraphics have #
    # been appropriately set                                           #
    ####################################################################

    # Add slide title
    titleText = slideInfo.titleText
    slideTitleBottom, title, flattenedTitle = formatTitle(
        presentation, slide, titleText, pageTitleSize
    )

    # Log slide's title
    reportSlideTitle(slideNumber, 3, flattenedTitle)

    ####################################################################
    # Get the dimensions of the content area to place all content in   #
    ####################################################################
    contentLeft, contentWidth, contentTop, contentHeight = getContentRect(
        presentation, slide, slideTitleBottom, marginBase
    )

    ####################################################################
    # Check whether there are too many elements in the sequence to     #
    # render - and warn if there are. Then calculate how many to render#
    ####################################################################
    if len(slideInfo.sequence) > maxBlocks:
        print(f"Too many blocks to render. Only {str(maxBlocks)} will be rendered.")
    blocksToRender = min(maxBlocks, len(slideInfo.sequence))

    ####################################################################
    # Get the dimensions of the rectangles we'll place the graphics in #
    # and their top left corner coordinates
    ####################################################################
    allContentSplit = 0
    contentSplit = processingOptions.getCurrentOption("contentSplit")
    for b in range(blocksToRender):
        allContentSplit = allContentSplit + contentSplit[b]

    verticalCursor = contentTop
    horizontalCursor = contentLeft

    codeBlockNumber = 0
    tableBlockNumber = 0

    for b in range(blocksToRender):
        if processingOptions.getCurrentOption("contentSplitDirection") == "vertical":
            # Height and top
            blockHeight = int(contentHeight * contentSplit[b] / allContentSplit)
            blockTop = verticalCursor
            verticalCursor = verticalCursor + blockHeight

            # Width and left
            blockWidth = contentWidth
            blockLeft = contentLeft
        else:
            # Height and top
            blockHeight = contentHeight
            blockTop = contentTop

            # Width and left
            blockWidth = int(contentWidth * contentSplit[b] / allContentSplit)
            blockLeft = horizontalCursor
            horizontalCursor = horizontalCursor + blockWidth

        renderingRectangle = Rectangle(blockTop, blockLeft, blockHeight, blockWidth)

        if slideInfo.sequence[b] == "table":
            createTableBlock(slideInfo, slide, renderingRectangle, tableBlockNumber)
            tableBlockNumber += 1

        elif slideInfo.sequence[b] == "list":
            createListBlock(slideInfo, slide, renderingRectangle)
        else:
            createCodeBlock(slideInfo, slide, renderingRectangle, codeBlockNumber)
            codeBlockNumber += 1

    if want_numbers_content is True:
        addFooter(presentation, slideNumber, slide)

    return slide


def createListBlock(slideInfo, slide, renderingRectangle):
    horizontalCardGap = processingOptions.getCurrentOption("horizontalcardgap")
    verticalCardGap = processingOptions.getCurrentOption("verticalcardgap")
    cardTitleAlign = processingOptions.getCurrentOption("cardtitlealign")
    cardTitlePosition = processingOptions.getCurrentOption("cardtitleposition")
    cardShape = processingOptions.getCurrentOption("cardshape")
    cardLayout = processingOptions.getCurrentOption("cardlayout")
    cardPercent = processingOptions.getCurrentOption("cardpercent")
    cardShadow = processingOptions.getCurrentOption("cardshadow")
    cardTitleSize = processingOptions.getCurrentOption("cardtitlesize")
    cardBorderWidth = processingOptions.getCurrentOption("cardborderwidth")
    cardBorderColour = processingOptions.getCurrentOption("cardbordercolour")
    cardColour = processingOptions.getCurrentOption("cardcolour")
    marginBase = processingOptions.getCurrentOption("marginBase")
    pageTitleSize = processingOptions.getCurrentOption("pageTitleSize")

    # Get bulleted text shape - either for bullets above cards or first card's body shape
    bulletsShape = findBodyShape(slide)

    # Set bulleted shape top, left, width
    bulletsShape.top = renderingRectangle.top
    bulletsShape.left = renderingRectangle.left
    bulletsShape.width = renderingRectangle.width

    bulletCount = len(slideInfo.bullets)

    # Set bulleted text height - depending on whether there's a card
    # Remainder is card area height - if there are cards
    if slideInfo.cards == []:
        # Bullets shape takes the whole content area
        bulletsShape.height = renderingRectangle.height

        # There are no cards so the card area is zero height
        cardAreaHeight = 0
        cardCount = 0
    else:
        if bulletCount > 0:
            # Bullets shape vertically shortened
            bulletsShape.height = int(
                renderingRectangle.height * (100 - cardPercent) / 100
            )

            # Card area takes the rest of the content area
            cardAreaHeight = int(renderingRectangle.height) - bulletsShape.height
        else:
            # No bullets so content is all cards
            bulletsShape.height = 0

            cardAreaHeight = renderingRectangle.height

        cardBackgroundShapes = []
        cardBodyShapes = []
        cardTitleShapes = []
        cardLeft = []
        cardTop = []
        cardBodyTop = []
        cardBackgroundTop = []
        cardTitleTop = []

        cardCount = len(slideInfo.cards)

        # card width applies to card title, card background, card body
        if cardLayout == "horizontal":
            # Divide horizontal card space up
            cardWidth = int(
                (renderingRectangle.width - Inches(horizontalCardGap) * (cardCount - 1))
                / cardCount
            )
        else:
            # Card takes all the horizontal space
            cardWidth = int(renderingRectangle.width)

        # Calculate title top and height - horizontal layout
        if cardTitleSize > 0:
            # Specified by user
            cardTitleHeightRaw = Inches(cardTitleSize / 72)
        else:
            # Shrunk to 2/3 of page title height
            cardTitleHeightRaw = Inches(int(10000 * pageTitleSize * 2 / 3 / 72) / 10000)

        # Adjust title height to be slightly larger than the text
        cardTitleHeight = cardTitleHeightRaw + Inches(0.1)

        if bulletCount > 0:
            # Bullets so cards and their titles occupy less than whole height
            cardAreaTop = bulletsShape.height + renderingRectangle.top

        else:
            # No bullets so cards and their titles occupy whole height
            cardAreaTop = renderingRectangle.top

        if cardLayout == "horizontal":
            # Card takes up all the card area, vertically
            cardHeight = cardAreaHeight
        else:
            # Card height is just a proportion of the card area height

            if cardTitlePosition == "above":
                paddingFactor = Inches(verticalCardGap - 0.05)
            else:
                paddingFactor = Inches(verticalCardGap)

            cardHeight = int((cardAreaHeight) / cardCount - paddingFactor)

        # Store slide title shape for cloning
        slideTitleShape = findTitleShape(slide)

        for c in range(cardCount):
            # Calculate a card's vertical position
            if cardLayout == "horizontal":
                cardTop.append(cardAreaTop)
            else:
                cardTop.append(int((cardHeight + paddingFactor) * c + cardAreaTop))

            # Card top and height
            if cardTitlePosition == "above":
                # Card title above card background
                cardBackgroundTop.append(cardTop[c] + cardTitleHeight)
                cardBodyTop.append(cardBackgroundTop[c])
            else:
                # card title inside card background
                cardBackgroundTop.append(cardTop[c])

                # Leave room above the card body for the card title
                cardBodyTop.append(cardBackgroundTop[c] + cardTitleHeight)

            # Calculate a card's horizontal position
            if cardLayout == "horizontal":
                cardLeft.append(
                    marginBase + c * (cardWidth + Inches(horizontalCardGap))
                )
            else:
                cardLeft.append(marginBase)

            # Card title modeled on slide title - but smaller
            cardTitleShape = addClonedShape(slide, slideTitleShape)

            cardTitleShapes.append(cardTitleShape)

            # Clear text from cloned title and add in the title text
            cardTitleShape.text_frame.paragraphs[0].text = ""
            addFormattedText(cardTitleShape.text_frame.paragraphs[0], cards[c][0])

            # Set card title font size
            if cardTitleSize > 0:
                cardTitleShape.text_frame.paragraphs[0].font.size = Pt(cardTitleSize)
            else:
                cardTitleShape.text_frame.paragraphs[0].font.size = Pt(
                    pageTitleSize * 2 / 3
                )

            # Titles are aligned one of three ways
            if cardTitleAlign == "l":
                cardTitleShape.text_frame.paragraphs[0].alignment = PP_ALIGN.LEFT
            elif cardTitleAlign == "c":
                cardTitleShape.text_frame.paragraphs[0].alignment = PP_ALIGN.CENTER
            else:
                cardTitleShape.text_frame.paragraphs[0].alignment = PP_ALIGN.RIGHT

            # Create card background and make sure it's behind the card body (and maybe card title)
            if cardShape == "rounded":
                # Rounded Rectangle for card
                cardBackgroundShape = slide.shapes.add_shape(
                    MSO_SHAPE.ROUNDED_RECTANGLE,
                    Inches(0),
                    Inches(0),
                    Inches(0),
                    Inches(0),
                )

                # Rounding adjustment works better with different values for horizontal and vertical cards
                if cardLayout == "horizontal":
                    # Make the rounding radius small. This is 1/4 the default
                    cardBackgroundShape.adjustments[0] = 0.0416675
                else:
                    # Make the rounding radius smallish. This is 1/2 the default
                    cardBackgroundShape.adjustments[0] = 0.083335
            else:
                # Squared-corner Rectangle for card
                cardBackgroundShape = slide.shapes.add_shape(
                    MSO_SHAPE.RECTANGLE, Inches(0), Inches(0), Inches(0), Inches(0)
                )

            cardBackgroundShapes.append(cardBackgroundShape)
            sendToBack(slide.shapes, cardBackgroundShape)

            # Card shape modeled on bulleted list
            if (bulletCount > 0) | (c > 0):
                cardBodyShape = addClonedShape(slide, bulletsShape)
            else:
                # Co-opt bullets shape as first card shape
                cardBodyShape = bulletsShape
            cardBodyShapes.append(cardBodyShape)

            # Make card's body transparent
            fill = cardBodyShape.fill
            fill.background()

            # Fill in card's background - if necessary
            if cardColour != "":
                fill = cardBackgroundShape.fill
                fill.solid()
                fill.fore_color.theme_color = cardColour

    # Adjust bullets shape height - and calculate verticals for any cards

    bulletsShape.bottom = bulletsShape.top + bulletsShape.height

    # Fill in the main bullets shape
    renderText(bulletsShape, slideInfo.bullets)

    for c in range(cardCount):
        # Get the shapes for this card
        cardBackgroundShape = cardBackgroundShapes[c]
        cardTitleShape = cardTitleShapes[c]
        cardBodyShape = cardBodyShapes[c]

        # Set the card shapes' width
        cardBackgroundShape.width = cardWidth
        cardBodyShape.width = cardWidth
        cardTitleShape.width = cardWidth

        # Set the card shapes' left side
        cardBackgroundShape.left = cardLeft[c]
        cardTitleShape.left = cardLeft[c]
        cardBodyShape.left = cardLeft[c]

        # Position card title
        cardTitleShape.top = cardTop[c]
        cardTitleShape.height = cardTitleHeight

        # Calculate positions and heights within card background of body
        if cardTitlePosition == "above":
            cardBackgroundShape.top = cardTop[c] + cardTitleHeight
            cardBodyHeight = cardHeight - cardTitleHeight
            cardBackgroundShape.height = cardBodyHeight
        else:
            cardBackgroundShape.top = cardTop[c]
            cardBodyHeight = cardHeight
            cardBackgroundShape.height = cardBodyHeight

        # Position card
        cardBodyShape.top = cardBodyTop[c]
        cardBodyShape.height = cardBodyHeight

        if len(cards[c]) > 1:
            renderText(cardBodyShape, slideInfo.cards[c][1])

        lf = cardBackgroundShape.line

        if cardBorderColour != "":
            lf.color.theme_color = cardBorderColour

        if cardBorderWidth > 0:
            lf.width = Pt(cardBorderWidth)

        if cardShadow:
            createShadow(cardBackgroundShape)

    return slide


def createTableBlock(slideInfo, slide, renderingRectangle, tableBlockNumber):
    tableRows = slideInfo.tableRows[tableBlockNumber]
    tableMargin = processingOptions.getCurrentOption("tableMargin")
    marginBase = processingOptions.getCurrentOption("marginBase")
    baseTextSize = processingOptions.getCurrentOption("baseTextSize")

    printableTopLeftGraphicFilename = ""
    printableTopRightGraphicFilename = ""
    printableBottomLeftGraphicFilename = ""
    printableBottomRightGraphicFilename = ""

    # Handle table body
    if (len(tableRows) <= 2) & (len(tableRows[0]) <= 2):
        # This is a table with 1 or 2 rows and 1 or 2 columns
        isGraphicsGrid = True
        gridRows = len(tableRows)
        if gridRows == 1:
            gridColumns = len(tableRows[0])
        else:
            gridColumns = max(len(tableRows[0]), len(tableRows[1]))
        topGraphicCount = 0

        # Attempt to retrieve filename for left side - top row
        topLeftSide = tableRows[0][0]
        if (graphicRegex.match(topLeftSide) != None) | (
            clickableGraphicRegex.match(topLeftSide) != None
        ):
            if clickableGraphicMatch := clickableGraphicRegex.match(topLeftSide):
                # Clickable graphic case
                topLeftGraphicTitle = clickableGraphicMatch.group(1)
                topLeftGraphicFilename = clickableGraphicMatch.group(2)
                topLeftGraphicHref = clickableGraphicMatch.group(3)
            else:
                # Graphic
                topLeftGraphicMatch = graphicRegex.match(topLeftSide)
                topLeftGraphicTitle = topLeftGraphicMatch.group(1)
                topLeftGraphicFilename = topLeftGraphicMatch.group(2)
                topLeftGraphicHref = ""

            (
                topLeftGraphicFilename,
                printableTopLeftGraphicFilename,
            ) = handleWhateverGraphicType(topLeftGraphicFilename)
            topLeftHTML = ""
            topGraphicCount += 1
        else:
            topLeftGraphicFilename = ""
            topLeftHTML = topLeftSide

        # Attempt to retrieve filename for right side - top row
        if gridColumns == 2:
            if len(tableRows[0]) == 2:
                topRightSide = tableRows[0][1]
            else:
                topRightSide = ""
            if (graphicRegex.match(topRightSide) != None) | (
                clickableGraphicRegex.match(topRightSide) != None
            ):
                if clickableGraphicMatch := clickableGraphicRegex.match(topRightSide):
                    # Clickable graphic case
                    topRightGraphicTitle = clickableGraphicMatch.group(1)
                    topRightGraphicFilename = clickableGraphicMatch.group(2)
                    topRightGraphicHref = clickableGraphicMatch.group(3)
                else:
                    # Graphic
                    topRightGraphicMatch = graphicRegex.match(topRightSide)
                    topRightGraphicTitle = topRightGraphicMatch.group(1)
                    topRightGraphicFilename = topRightGraphicMatch.group(2)
                    topRightGraphicHref = ""

                (
                    topRightGraphicFilename,
                    printableTopRightGraphicFilename,
                ) = handleWhateverGraphicType(topRightGraphicFilename)
                topRightHTML = ""
                topGraphicCount += 1
            else:
                topRightGraphicFilename = ""
                topRightHTML = topRightSide
        else:
            topRightGraphicFilename = ""
            topRightHTML = ""

        if topGraphicCount == 0:
            # Revert to normal table processing as no graphic spec in at least one cell
            isGraphicsGrid = False

        if gridRows == 2:
            # Attempt to retrieve filename for left side - bottom row
            bottomGraphicCount = 0
            bottomLeftSide = tableRows[1][0]
            if (graphicRegex.match(bottomLeftSide) != None) | (
                clickableGraphicRegex.match(bottomLeftSide) != None
            ):
                if clickableGraphicMatch := clickableGraphicRegex.match(bottomLeftSide):
                    # Clickable graphic case
                    bottomLeftGraphicTitle = clickableGraphicMatch.group(1)
                    bottomLeftGraphicFilename = clickableGraphicMatch.group(2)
                    bottomLeftGraphicHref = clickableGraphicMatch.group(3)
                else:
                    # Graphic
                    bottomLeftGraphicMatch = graphicRegex.match(bottomLeftSide)
                    bottomLeftGraphicTitle = bottomLeftGraphicMatch.group(1)
                    bottomLeftGraphicFilename = bottomLeftGraphicMatch.group(2)
                    bottomLeftGraphicHref = ""

                (
                    bottomLeftGraphicFilename,
                    printableBottomLeftGraphicFilename,
                ) = handleWhateverGraphicType(bottomLeftGraphicFilename)
                bottomLeftHTML = ""
                bottomGraphicCount += 1
            else:
                bottomLeftGraphicFilename = ""
                bottomLeftHTML = bottomLeftSide

            # Attempt to retrieve filename for right side - bottom row
            if gridColumns == 2:
                if len(tableRows[1]) == 1:
                    # There is one cell in bottom row so this is centred "3-up"
                    bottomRightGraphicFilename = ""
                else:
                    # There is a bottom right so this is "4-up", though one or OTHER_MEMBERS
                    # bottom cells might be empty
                    bottomRightSide = tableRows[1][1]
                    if (graphicRegex.match(bottomRightSide) != None) | (
                        clickableGraphicRegex.match(bottomRightSide) != None
                    ):
                        if clickableGraphicMatch := clickableGraphicRegex.match(
                            bottomRightSide
                        ):
                            # Clickable graphic case
                            bottomRightGraphicTitle = clickableGraphicMatch.group(1)
                            bottomRightGraphicFilename = clickableGraphicMatch.group(2)
                            bottomRightGraphicHref = clickableGraphicMatch.group(3)
                        else:
                            # Graphic
                            bottomRightGraphicMatch = graphicRegex.match(
                                bottomRightSide
                            )
                            bottomRightGraphicTitle = bottomRightGraphicMatch.group(1)
                            bottomRightGraphicFilename = bottomRightGraphicMatch.group(
                                2
                            )
                            bottomRightGraphicHref = ""

                        (
                            bottomRightGraphicFilename,
                            printableBottomRightGraphicFilename,
                        ) = handleWhateverGraphicType(bottomRightGraphicFilename)
                        bottomRightHTML = ""
                        bottomGraphicCount += 1
                    else:
                        bottomRightGraphicFilename = ""
                        bottomRightHTML = bottomRightSide
            else:
                bottomRightGraphicFilename = ""
                bottomRightHTML = ""

            if bottomGraphicCount == 0:
                # Revert to normal table processing as no graphic spec in at least one cell
                isGraphicsGrid = False

    else:
        # This is a normal table because it has too many rows or columns to be a graphics grid
        isGraphicsGrid = False

    if isGraphicsGrid == True:
        ####################################################################
        # Print the graphic filenames                                      #
        ####################################################################
        if gridColumns == 2:
            # Doing 1- or 2-row side-by-side graphics slide
            reportGraphicFileNames(
                printableTopLeftGraphicFilename, printableTopRightGraphicFilename
            )
        else:
            # Doing 2 row, single column graphics slide
            reportGraphicFileNames(printableTopLeftGraphicFilename)

        if gridRows == 2:
            # Second row of filenames
            if gridColumns == 2:
                reportGraphicFileNames(
                    printableBottomLeftGraphicFilename,
                    printableBottomRightGraphicFilename,
                )
            else:
                reportGraphicFileNames(printableBottomLeftGraphicFilename)

        ####################################################################
        # Get the image dimensions                                         #
        ####################################################################
        if topLeftGraphicFilename != "":
            topLeftImgWidth, topLeftImgHeight = get_image_size(topLeftGraphicFilename)
            if topLeftImgWidth == -1:
                if gridRows == 2:
                    print(
                        "Missing top left image file: "
                        + printableTopLeftGraphicFilename
                    )
                else:
                    print("Missing left image file: " + printableTopLeftGraphicFilename)

                return slide

        if gridColumns == 2:
            # Get top right image dimensions
            if topRightGraphicFilename != "":
                topRightImgWidth, topRightImgHeight = get_image_size(
                    topRightGraphicFilename
                )
                if topRightImgWidth == -1:
                    if gridRows == 2:
                        print(
                            "Missing top right image file: "
                            + printableTopRightGraphicFilename
                        )
                    else:
                        print(
                            "Missing right image file: "
                            + printableTopRightGraphicFilename
                        )

                    return slide

        if gridRows == 2:
            # Get bottom left image dimensions
            if bottomLeftGraphicFilename != "":
                bottomLeftImgWidth, bottomLeftImgHeight = get_image_size(
                    bottomLeftGraphicFilename
                )
                if bottomLeftImgWidth == -1:
                    print(
                        "Missing bottom left image file: "
                        + printableBottomLeftGraphicFilename
                    )
                    return slide

            if gridColumns == 2:
                if bottomRightGraphicFilename == "":
                    bottomRightImgWidth = 0
                    bottomRightImgHeight = 0
                else:
                    # Get bottom right image dimensions
                    if bottomRightGraphicFilename != "":
                        bottomRightImgWidth, bottomRightImgHeight = get_image_size(
                            bottomRightGraphicFilename
                        )
                        if bottomRightImgWidth == -1:
                            print(
                                "Missing bottom right image file: "
                                + printableBottomRightGraphicFilename
                            )
                            return slide

        # Calculate maximum picture height on slide
        maxPicHeight = renderingRectangle.height
        if gridRows == 2:
            # Adjusted if two rows
            maxPicHeight = maxPicHeight / 2 + Inches(0.2)

        # Calculate maximum picture width on slide
        maxPicWidth = renderingRectangle.width
        if gridColumns == 2:
            # Adjusted if two columns
            maxPicWidth = maxPicWidth / 2 - marginBase

        # Calculate horizontal middle of graphics space
        midGraphicsSpaceX = renderingRectangle.left + renderingRectangle.width / 2

        ####################################################################
        # Calculate the size of each graphic - scaled by the above rect    #
        ####################################################################
        if topLeftGraphicFilename != "":
            (topLeftPicWidth, topLeftPicHeight, usingHeightToScale,) = scalePicture(
                maxPicWidth, maxPicHeight, topLeftImgWidth, topLeftImgHeight
            )

            if usingHeightToScale:
                # Calculate horizontal start
                if (gridColumns == 2) and (topRightGraphicFilename != ""):
                    # Align top left picture to the left
                    topLeftPicX = (
                        renderingRectangle.left
                        + (midGraphicsSpaceX - marginBase - topLeftPicWidth) / 2
                    )
                else:
                    # Center sole top picture
                    topLeftPicX = midGraphicsSpaceX - topLeftPicWidth / 2
            else:
                # Calculate horizontal start
                if (gridColumns == 2) & (topRightGraphicFilename != ""):
                    # Align top left picture to the left
                    topLeftPicX = renderingRectangle.left
                else:
                    # Center sole top picture
                    topLeftPicX = midGraphicsSpaceX - topLeftPicWidth / 2

            # Calculate vertical start
            topLeftPicY = renderingRectangle.top + (maxPicHeight - topLeftPicHeight) / 2

            if gridRows == 2:
                topLeftPicY -= Inches(0.2)

            topLeftPicture = slide.shapes.add_picture(
                topLeftGraphicFilename,
                topLeftPicX,
                topLeftPicY,
                topLeftPicWidth,
                topLeftPicHeight,
            )

            if topLeftGraphicHref == "":
                topLeftGraphicHref = "#XYZZY-None"

            pictureInfos.append(
                (topLeftPicture, topLeftGraphicHref, topLeftGraphicTitle)
            )

        if gridColumns == 2:
            # Top Right Picture
            if topRightGraphicFilename != "":
                (
                    topRightPicWidth,
                    topRightPicHeight,
                    usingHeightToScale,
                ) = scalePicture(
                    maxPicWidth, maxPicHeight, topRightImgWidth, topRightImgHeight
                )

                if usingHeightToScale:
                    # Calculate horizontal start
                    topRightPicX = (
                        renderingRectangle.width + midGraphicsSpaceX - topRightPicWidth
                    ) / 2
                else:
                    # Calculate horizontal start
                    topRightPicX = (
                        renderingRectangle.width + midGraphicsSpaceX - topRightPicWidth
                    ) / 2

                # Calculate vertical start
                topRightPicY = (
                    renderingRectangle.top + (maxPicHeight - topRightPicHeight) / 2
                )

                if gridRows == 2:
                    topRightPicY -= Inches(0.2)

                topRightPicture = slide.shapes.add_picture(
                    topRightGraphicFilename,
                    topRightPicX,
                    topRightPicY,
                    topRightPicWidth,
                    topRightPicHeight,
                )

                if topRightGraphicHref == "":
                    topRightGraphicHref = "#XYZZY-None"

                pictureInfos.append(
                    (topRightPicture, topRightGraphicHref, topRightGraphicTitle)
                )

        if gridRows == 2:
            # Need second row of pictures
            # Bottom Left Picture
            if bottomLeftGraphicFilename != "":
                (
                    bottomLeftPicWidth,
                    bottomLeftPicHeight,
                    usingHeightToScale,
                ) = scalePicture(
                    maxPicWidth, maxPicHeight, bottomLeftImgWidth, bottomLeftImgHeight
                )

                if usingHeightToScale:
                    # Calculate horizontal start
                    if (gridColumns == 2) & (bottomRightGraphicFilename != ""):
                        bottomLeftPicX = (
                            marginBase
                            + (midGraphicsSpaceX - marginBase - bottomLeftPicWidth) / 2
                        )
                    else:
                        bottomLeftPicX = midGraphicsSpaceX - bottomLeftPicWidth / 2
                else:
                    # Calculate horizontal start
                    if (gridColumns == 2) and (bottomRightGraphicFilename != ""):
                        # Align bottom left picture to the left
                        bottomLeftPicX = marginBase
                    else:
                        # Center sole bottom picture
                        bottomLeftPicX = midGraphicsSpaceX - bottomLeftPicWidth / 2

                # Calculate vertical start
                bottomLeftPicY = (
                    renderingRectangle.top + (maxPicHeight + bottomLeftPicHeight) / 2
                )

                if gridRows == 2:
                    bottomLeftPicY -= Inches(0.2)

                bottomLeftPicture = slide.shapes.add_picture(
                    bottomLeftGraphicFilename,
                    bottomLeftPicX,
                    bottomLeftPicY,
                    bottomLeftPicWidth,
                    bottomLeftPicHeight,
                )

                if bottomLeftGraphicHref == "":
                    bottomLeftGraphicHref = "#XYZZY-None"

                pictureInfos.append(
                    (bottomLeftPicture, bottomLeftGraphicHref, bottomLeftGraphicTitle)
                )

            if gridColumns == 2:
                # Bottom Right Picture

                if bottomRightGraphicFilename != "":
                    (
                        bottomRightPicWidth,
                        bottomRightPicHeight,
                        usingHeightToScale,
                    ) = scalePicture(
                        maxPicWidth,
                        maxPicHeight,
                        bottomRightImgWidth,
                        bottomRightImgHeight,
                    )

                    if usingHeightToScale:
                        # Calculate horizontal start
                        bottomRightPicX = (
                            renderingRectangle.width
                            + midGraphicsSpaceX
                            - bottomRightPicWidth
                        ) / 2

                    else:
                        # Use the width to scale
                        # Calculate horizontal start
                        bottomRightPicX = (
                            renderingRectangle.width
                            + midGraphicsSpaceX
                            - bottomRightPicWidth
                        ) / 2

                    # Calculate vertical start
                    bottomRightPicY = (
                        renderingRectangle.top
                        + (maxPicHeight + bottomRightPicHeight) / 2
                    )

                    if gridRows == 2:
                        bottomRightPicY -= Inches(0.2)

                    if bottomRightGraphicFilename != "":
                        bottomRightPicture = slide.shapes.add_picture(
                            bottomRightGraphicFilename,
                            bottomRightPicX,
                            bottomRightPicY,
                            bottomRightPicWidth,
                            bottomRightPicHeight,
                        )

                        if bottomRightGraphicHref == "":
                            bottomRightGraphicHref = "#XYZZY-None"

                        pictureInfos.append(
                            (
                                bottomRightPicture,
                                bottomRightGraphicHref,
                                bottomRightGraphicTitle,
                            )
                        )

    else:
        # Normal table slide

        # Calculate maximum number of columns - as this is how wide we'll make the table
        columns = 0
        for row in tableRows:
            columns = max(columns, len(row))

        alignments = []
        widths = []

        # Adjust table if it contains a dash line as it's second line
        if len(tableRows) > 1:
            firstCellSecondRow = tableRows[1][0]
            if (firstCellSecondRow.startswith("-")) | (
                firstCellSecondRow.startswith(":-")
            ):
                haveTableHeading = True
            else:
                haveTableHeading = False
        else:
            haveTableHeading = False

        if haveTableHeading is True:
            # Has table heading
            tableHeadingBlurb = " with heading"

            # Figure out alignments of cells
            for cell in tableRows[1]:
                if cell.startswith(":-"):
                    if cell.endswith("-:"):
                        alignments.append("c")
                    else:
                        alignments.append("l")
                elif cell.endswith("-:"):
                    alignments.append("r")
                else:
                    alignments.append("l")

                widths.append(cell.count("-"))

            # Default any missing columns to left / single width
            if len(tableRows[1]) < columns:
                for _ in range(columns - len(tableRows[1])):
                    alignments.append("l")
                    widths.append(1)

            widths_total = sum(widths)

            # Remove this alignment / widths row from the table
            del tableRows[1]
            wantTableHeading = True
        else:
            # No table heading
            tableHeadingBlurb = " without heading"
            wantTableHeading = False

            # Use default width - 1 - and default alignment - l
            for c in range(columns):
                widths.append(1)
                alignments.append("l")

            # We don't know the widths so treat all equal
            widths_total = columns

        # Calculate number of rows
        rows = len(tableRows)
        alignments_count = len(alignments)

        # Create the table with the above number of rows and columns
        newTableShape = slide.shapes.add_table(rows, columns, 0, 0, 0, 0)
        newTable = newTableShape.table

        newTableShape.top = renderingRectangle.top
        newTableShape.left = renderingRectangle.left + tableMargin - marginBase
        newTableShape.height = min(renderingRectangle.height, Inches(0.25) * rows)
        newTableShape.width = renderingRectangle.width - 2 * (tableMargin - marginBase)
        shapeWidth = newTableShape.width

        # Set whether first row is not special
        newTable.first_row = wantTableHeading

        print(
            "           --> "
            + str(rows)
            + " x "
            + str(columns)
            + " table"
            + tableHeadingBlurb
        )

        # Set column widths
        cols = newTable.columns
        for colno in range(columns):
            cols[colno].width = int(shapeWidth * widths[colno] / widths_total)

        # Fill in the cells
        compactTables = processingOptions.getCurrentOption("compactTables")
        for rowNumber, row in enumerate(tableRows):
            # Add dummy cells to the end of the row so that there are as many
            # cells in the row as there are columns in the table
            cellCount = len(row)
            for c in range(cellCount, columns):
                row.append("")
            for columnNumber, cell in enumerate(row):
                newCell = newTable.cell(rowNumber, columnNumber)

                # For compact table remove the margins around the text
                if compactTables > 0:
                    newCell.margin_top = Pt(0)
                    newCell.margin_bottom = Pt(0)

                newCell.text = ""
                text_frame = newCell.text_frame

                # Set cell's text alignment
                p = text_frame.paragraphs[0]

                # Set cell's text size - if necessary
                if baseTextSize > 0:
                    p.font.size = Pt(baseTextSize)

                # For compact table use specified point size for text
                if compactTables > 0:
                    p.font.size = Pt(compactTables)

                if columnNumber >= alignments_count:
                    p.alignment = PP_ALIGN.LEFT
                elif alignments[columnNumber] == "r":
                    p.alignment = PP_ALIGN.RIGHT
                elif alignments[columnNumber] == "c":
                    p.alignment = PP_ALIGN.CENTER
                else:
                    p.alignment = PP_ALIGN.LEFT

                addFormattedText(p, cell)

        # Apply table border styling - whether there is any or not
        applyTableLineStyling(
            newTable,
            processingOptions,
        )

    return slide


def createChevron(
    text,
    x,
    y,
    width,
    height,
    filled,
    shapes,
    fontSize,
    wantLink,
    unhighlightedBackground,
):
    global TOCruns

    # Create shape
    shape = shapes.add_shape(MSO_SHAPE.CHEVRON, x, y, width, height)

    # Set shape's text
    shape.text = text

    # Set shape's text attributes
    tf = shape.text_frame
    p = tf.paragraphs[0]
    f = p.font
    f.size = Pt(fontSize)
    f.color.rgb = RGBColor(0, 0, 0)

    # If want link create it from the first run
    if wantLink:
        TOCruns.append(p.runs[0])

    # Set shape's outline attributes
    shape.line.color.rgb = RGBColor(0, 0, 0)
    shape.line.width = Pt(1.0)

    # Potentially fill background
    if filled is False:
        shape.fill.background()
    else:
        if wantLink & (unhighlightedBackground != ""):
            shape.fill.solid()
            shape.fill.fore_color.rgb = RGBColor.from_string(unhighlightedBackground)


def createOval(
    text,
    x,
    y,
    width,
    height,
    filled,
    shapes,
    fontSize,
    wantLink,
    unhighlightedBackground,
):
    global TOCruns

    # Create shape
    shape = shapes.add_shape(MSO_SHAPE.OVAL, x, y, width, height)

    # Set shape's text
    shape.text = text

    # Set shape's text attributes
    tf = shape.text_frame
    p = tf.paragraphs[0]
    p.alignment = PP_ALIGN.CENTER
    f = p.font
    f.size = Pt(fontSize)
    f.color.rgb = RGBColor(0, 0, 0)

    # If want link create it from the first run
    if wantLink:
        TOCruns.append(p.runs[0])

    # Set shape's outline attributes
    shape.line.color.rgb = RGBColor(191, 191, 191)
    shape.line.width = Pt(1.0)

    # Potentially fill background
    if filled is False:
        shape.fill.background()
        shape.line.width = Pt(3.0)
    else:
        if wantLink & (unhighlightedBackground != ""):
            shape.fill.solid()
            shape.fill.fore_color.rgb = RGBColor.from_string(unhighlightedBackground)


def createLine(x0, y0, x1, y1, shapes):
    # Create line
    line = shapes.add_shape(MSO_SHAPE.LINE_INVERSE, x0, y0, x1 - x0, y1 - y0)

    # Set shape's outline attributes
    line.line.color.rgb = RGBColor(191, 191, 191)
    line.line.width = Pt(4.0)


def delinkify(text):
    if linkMatch := linkRegex.match(text):
        linkText = linkMatch.group(1)
        linkURL = linkMatch.group(2)

        return (linkText, linkURL)
    else:
        return (text, "")


def createTOCSlide(presentation, slideNumber, titleText, bullets, tocStyle):
    global SectionSlides
    titleOnlyLayout = processingOptions.getCurrentOption("titleOnlyLayout")
    blankLayout = processingOptions.getCurrentOption("blankLayout")
    tocTitle = processingOptions.getCurrentOption("tocTitle")
    marginBase = processingOptions.getCurrentOption("marginBase")
    pageTitleSize = processingOptions.getCurrentOption("pageTitleSize")

    if tocStyle != "plain":
        if titleText == tocTitle:
            reportSlideTitle(
                slideNumber, 3, f'Table Of Contents (Style: "{tocStyle}") {titleText}'
            )

        else:
            reportSlideTitle(slideNumber, 2, titleText)

    if tocStyle == "plain":
        if titleText != tocTitle:
            slide = createTitleOrSectionSlide(
                presentation,
                slideNumber,
                titleText,
                processingOptions.getCurrentOption("sectionSlideLayout"),
                processingOptions.getCurrentOption("sectionTitleSize"),
                slideInfo.subtitleText,
                processingOptions.getCurrentOption("sectionSubtitleSize"),
                notes_text,
            )
        else:
            # Remove the links from the bullets and replace with target slide title
            for bullet in bullets:
                linkMatch = linkRegex.match(bullet[1])
                bullet[1] = linkMatch.group(1)

            # Create the TOC slide - with these neutralised titles
            slide = createContentSlide(
                presentation,
                slideNumber,
                slideInfo,
            )

            # Postprocess slide to pick up runs - for TOC creation
            body = findBodyShape(slide)
            text_frame = body.text_frame
            for p in text_frame.paragraphs:
                TOCruns.append(p.runs[0])

        # Store the new slide in the list of section slides - for fixing up links
        SectionSlides[titleText] = slide

        return slide

    else:
        slide = presentation.slides.add_slide(
            presentation.slide_layouts[titleOnlyLayout]
        )
        title = findTitleShape(slide)

    SectionSlides[titleText] = slide

    shapes = slide.shapes

    # Add title if TOC slide. Or delete shape if not
    if titleText == tocTitle:
        # Is TOC slide so add title
        slideTitleBottom, title, flattenedTitle = formatTitle(
            presentation, slide, tocTitle, pageTitleSize
        )
    else:
        # Is not TOC slide so delete title shape and adjust where title bottom
        # would be
        deleteSimpleShape(title)
        slideTitleBottom = marginBase

    # Get the rectangle the content will draw in
    contentLeft, contentWidth, contentTop, contentHeight = getContentRect(
        presentation, slide, slideTitleBottom, marginBase
    )

    # Create global list of TOC entries
    for bullet in bullets:
        bulletLevel, bulletText, bulletType = bullet
        if bulletLevel == 0:
            # Level 0 is top level so create a TOC entry
            linkText, linkHref = delinkify(bulletText)
            TOCEntries.append([linkText, linkHref])

    TOCEntryCount = len(TOCEntries)

    TOCFontSize = processingOptions.getCurrentOption("TOCFontSize")

    TOCItemHeight = processingOptions.getCurrentOption("TOCItemHeight")

    TOCItemColour = processingOptions.getCurrentOption("TOCItemColour")

    height = Inches(TOCItemHeight)

    if tocStyle == "chevron":
        if height == 0:
            height = Inches(1)

        width = height * 2.5

        entryGap = Inches(-0.5 * height / Inches(1))

        if TOCFontSize == 0:
            TOCFontSize = 14

    elif tocStyle == "circle":
        if height == 0:
            height = Inches(1.25)

        width = height

        entryGap = Inches(0.5)

        if TOCFontSize == 0:
            TOCFontSize = 12

    rowGap = Inches(processingOptions.getCurrentOption("TOCRowGap"))

    TOCEntriesPerRow = int(
        (presentation.slide_width - 2 * marginBase) / (width + entryGap)
    )

    rowCount = 1 + TOCEntryCount / TOCEntriesPerRow

    # Calculate actual TOC height so it can be vertically centred
    TOCHeight = (rowCount * height) + ((rowCount - 1) * rowGap)

    # Calculate where top of TOC should be
    TOCtop = slideTitleBottom + (contentHeight - TOCHeight + height) / 2

    # Calculate actual TOC width
    TOCWidth = TOCEntriesPerRow * (width + entryGap)

    # Calculate where the TOC will start
    TOCleft = (presentation.slide_width - TOCWidth + entryGap) / 2

    x = TOCleft
    y = TOCtop

    AbsoluteTOCEntryNumber = 1

    TOCEntryNumber = 1

    for entry in TOCEntries:
        entryText = entry[0]
        entryHref = entry[1]

        if entryText == titleText:
            wantFilled = False
            wantLink = False
        else:
            wantFilled = True
            wantLink = True

        if tocStyle == "chevron":
            createChevron(
                entryText,
                x,
                y,
                width,
                height,
                wantFilled,
                shapes,
                TOCFontSize,
                wantLink,
                TOCItemColour,
            )

        elif tocStyle == "circle":
            # Create the circle
            createOval(
                entryText,
                x,
                y,
                width,
                height,
                wantFilled,
                shapes,
                TOCFontSize,
                wantLink,
                TOCItemColour,
            )

            # Create half connector to next one - if not last
            if AbsoluteTOCEntryNumber < TOCEntryCount:
                connector = createLine(
                    x + width,
                    y + height / 2,
                    x + width + entryGap / 2,
                    y + height / 2,
                    shapes,
                )

            # Create half connector to previous one - if not first
            if AbsoluteTOCEntryNumber > 1:
                # z =1
                connector = createLine(
                    x - entryGap / 2, y + height / 2, x, y + height / 2, shapes
                )

        # Prepare for the next TOC entry - even if there isn't one
        x = x + width + entryGap

        # If beyond end of line the next TOC entry would be at the start of the next line
        AbsoluteTOCEntryNumber = AbsoluteTOCEntryNumber + 1
        TOCEntryNumber = TOCEntryNumber + 1
        if TOCEntryNumber == TOCEntriesPerRow + 1:
            x = TOCleft
            y = y + rowGap + height
            TOCEntryNumber = 1

    if want_numbers_content is True:
        addFooter(presentation, slideNumber, slide)

    return slide


def createSlide(presentation, slideNumber, slideInfo):
    abstractTitle = processingOptions.getCurrentOption("abstractTitle")
    tocTitle = processingOptions.getCurrentOption("tocTitle")
    tocStyle = processingOptions.getCurrentOption("tocStyle")
    sectionTitleSize = processingOptions.getCurrentOption("sectionTitleSize")
    sectionSubtitleSize = processingOptions.getCurrentOption("sectionSubtitleSize")

    if slideInfo.blockType in ["content", "code", "table"]:
        if (tocStyle != "") & (tocTitle == slideInfo.titleText):
            # This is a Table Of Contents slide
            slide = createTOCSlide(
                presentation,
                slideNumber,
                slideInfo.titleText,
                slideInfo.bullets,
                tocStyle,
            )
        elif (abstractTitle != "") & (abstractTitle == slideInfo.titleText):
            # This is an abstract slide
            slide = createAbstractSlide(
                presentation,
                slideNumber,
                slideInfo.titleText,
                slideInfo.bullets,
            )
        else:
            # This is an ordinary contents slide
            slide = createContentSlide(
                presentation,
                slideNumber,
                slideInfo,
            )

    elif slideInfo.blockType == "section":
        if tocStyle != "":
            # This is a section slide in TOC style
            slide = createTOCSlide(
                presentation,
                slideNumber,
                slideInfo.titleText,
                slideInfo.bullets,
                tocStyle,
            )
        else:
            slide = createTitleOrSectionSlide(
                presentation,
                slideNumber,
                slideInfo.titleText,
                processingOptions.getCurrentOption("sectionSlideLayout"),
                sectionTitleSize,
                slideInfo.subtitleText,
                sectionSubtitleSize,
                notes_text,
            )

    elif slideInfo.blockType == "title":
        slide = createTitleOrSectionSlide(
            presentation,
            slideNumber,
            slideInfo.titleText,
            processingOptions.getCurrentOption("titleSlideLayout"),
            sectionTitleSize,
            slideInfo.subtitleText,
            sectionSubtitleSize,
            notes_text,
        )

    slideNumber = slideNumber + 1

    sequence = []
    return [slideNumber, slide, sequence]


def createTaskSlides(prs, slideNumber, tasks, titleStem):
    tasksPerPage = processingOptions.getCurrentOption("tasksPerPage")

    taskSlideNumber = 0

    taskCount = len(tasks)
    for taskNumber, task in enumerate(tasks):
        if taskNumber % tasksPerPage == 0:
            # Is first task in a page
            if taskNumber > 0:
                # Print a "tasks" slide - as we have one to print out
                taskSlideNumber += 1
                if taskCount > tasksPerPage:
                    # More than one task page
                    title = titleStem + " - " + str(taskSlideNumber)
                else:
                    # Only one task page
                    title = titleStem

                taskBlock = [taskRows]

                slideInfo = SlideInfo(
                    title, "", "table", [], taskBlock, [], [], ["table"]
                )
                slide = createContentSlide(prs, slideNumber, slideInfo)

                # Fix up references to be active links to the slide where the task
                # was declared
                table = findBodyShape(slide).table
                for row in table.rows:
                    cell0Text = row.cells[0].text
                    if cell0Text not in ["Slide", ""]:
                        # First cell refers to a specific slide number - so link to it
                        run = row.cells[0].text_frame.paragraphs[0].runs[0]
                        createRunHyperlinkOrTooltip(
                            run, prs.slides[int(cell0Text) - 2 + templateSlideCount], ""
                        )

                slideNumber += 1

            taskRows = [["Slide", "Due", "Task", "Tags", "Done"]]
            taskRows.append(["-:", ":--:", ":----", ":----", ":--:"])
            old_sNum = 0

        sNum, taskText, dueDate, tags, done = task

        if tags != "":
            # Sort tags - if there are any
            tagList = re.split("[, ]", tags)
            sortedTagList = sorted(tagList)
            tags = str.join(",", sortedTagList)

        if sNum != old_sNum:
            taskRows.append([str(sNum), dueDate, taskText, tags, done])
        else:
            taskRows.append(["", dueDate, taskText, tags, done])
        old_sNum = sNum

    # Print a final "tasks" slide
    taskSlideNumber += 1
    if taskCount > tasksPerPage:
        title = titleStem + " - " + str(taskSlideNumber)
    else:
        title = titleStem

    taskBlock = [taskRows]
    slideInfo = SlideInfo(title, "", "table", [], taskBlock, [], [], ["table"])
    slide = createContentSlide(prs, slideNumber, slideInfo)

    # Fix up references to be active links to the slide where the task
    # was declared
    table = findBodyShape(slide).table
    for row in table.rows:
        cell0Text = row.cells[0].text
        if cell0Text not in ["Slide", ""]:
            # First cell refers to a specific slide number - so link to it
            run = row.cells[0].text_frame.paragraphs[0].runs[0]
            createRunHyperlinkOrTooltip(
                run, prs.slides[int(cell0Text) - 2 + templateSlideCount], ""
            )

    slideNumber += 1


def createGlossarySlides(prs, slideNumber, abbrevDictionary):
    termSlideNumber = 0
    glossarySlides = []

    glossaryTitle = processingOptions.getCurrentOption("glossaryTitle")
    glossaryTerm = processingOptions.getCurrentOption("glossaryTerm")
    glossaryTermsPerPage = processingOptions.getCurrentOption("glossaryTermsPerPage")
    glossaryMeaningWidth = processingOptions.getCurrentOption("glossaryMeaningWidth")
    glossaryMeaning = processingOptions.getCurrentOption("glossaryMeaning")

    termCount = len(abbrevDictionary)

    for termNumber, term in enumerate(sorted(abbrevDictionary.keys())):
        if termNumber % glossaryTermsPerPage == 0:
            # Is first glossary term in a page
            if termNumber > 0:
                # Print a "glossary" slide - as we have one to print out
                termSlideNumber += 1
                if termCount > glossaryTermsPerPage:
                    # More than one glossary page
                    title = glossaryTitle + " - " + str(termSlideNumber)
                else:
                    # Only one glossary page
                    title = glossaryTerm

                glossaryBlock = [glossaryRows]
                slideInfo = SlideInfo(
                    title, "", "table", [], glossaryBlock, [], [], ["table"]
                )
                slide = createContentSlide(prs, slideNumber, slideInfo)

                glossarySlides.append(slide)
                slideNumber += 1

            glossaryRows = [[glossaryTerm, glossaryMeaning]]
            glossaryRows.append([":-", ":" + ("-" * glossaryMeaningWidth)])
            old_sNum = 0

        meaning = abbrevDictionary.get(term)

        glossaryRows.append([term, meaning])

    # Print a final "glossary" slide
    termSlideNumber += 1
    if termCount > glossaryTermsPerPage:
        # More than one glossary page
        title = glossaryTitle + " - " + str(termSlideNumber)
    else:
        # Only one glossary page
        title = glossaryTitle

    glossaryBlock = [glossaryRows]
    slideInfo = SlideInfo(title, "", "table", [], glossaryBlock, [], [], ["table"])
    slide = createContentSlide(prs, slideNumber, slideInfo)
    glossarySlides.append(slide)
    slideNumber += 1

    return slideNumber, glossarySlides


def createSlideNotes(slide, notes_text):
    # Remove surrounding white space
    notes_text = notes_text.strip().lstrip("\n")

    if slide.notes_slide.notes_text_frame.text != "":
        # Notes already filled in
        return

    if notes_text != "":
        # There is substantive slide note text so create the note
        notes_slide = slide.notes_slide
        text_frame = notes_slide.notes_text_frame

        # addFormattedText handles eg hyperlinks and entity references
        addFormattedText(text_frame.paragraphs[0], notes_text)


def createFootnoteSlides(prs, slideNumber, footnoteDefinitions):
    footnotesSlideNumber = 0
    footnoteSlides = []

    footnotesTitle = processingOptions.getCurrentOption("footnotesTitle")
    footnotesPerPage = processingOptions.getCurrentOption("footnotesPerPage")

    footnoteCount = len(footnoteDefinitions)

    for footnoteNumber, footnote in enumerate(footnoteDefinitions):
        if footnoteNumber % footnotesPerPage == 0:
            # Is first footnote in a page
            if footnoteNumber > 0:
                # Print a "footnotes" slide - as we have one to print out
                footnotesSlideNumber += 1
                if footnoteCount > footnotesPerPage:
                    # More than one footnotes page
                    title = footnotesTitle + " - " + str(footnotesSlideNumber)
                else:
                    # Only one footnotes page
                    title = footnotesTitle

                slideInfo = SlideInfo(
                    title, "", "content", bullets, [], cards, [], ["list"]
                )
                slideNumber, slide, sequence = createSlide(prs, slideNumber, slideInfo)

                footnoteSlides.append(slide)

                # Turn off bulleting
                removeBullets(findBodyShape(slide).text_frame)

                slideNumber += 1
            bullets = []
            old_sNum = 0

        bullets.append(
            [
                1,
                str(footnoteNumber + 1) + ". " + footnoteDefinitions[footnoteNumber][1],
                "bullet",
            ]
        )

    # Print a final "footnote" slide
    footnotesSlideNumber += 1
    if footnoteCount > footnotesPerPage:
        # More than one footnotes page
        title = footnotesTitle + " - " + str(footnotesSlideNumber)
    else:
        # Only one footnotes page
        title = footnotesTitle

    slideInfo = SlideInfo(title, "", "content", bullets, [], cards, [], ["list"])
    slideNumber, slide, sequence = createSlide(prs, slideNumber, slideInfo)

    footnoteSlides.append(slide)

    # Turn off bulleting
    removeBullets(findBodyShape(slide).text_frame)

    slideNumber += 1

    return slideNumber, footnoteSlides


start_time = time.time()

banner = (
    "md2pptx Markdown To Powerpoint Converter " + md2pptx_level + " " + md2pptx_date
)

bannerUnderline = ""
for i in range(len(banner)):
    bannerUnderline = bannerUnderline + "="

print("\n" + banner + "\n" + bannerUnderline)
print("\nOpen source project: https://github.com/MartinPacker/md2pptx")

print("\nPython: " + platform.python_version())
print("python-pptx: " + pptx_version)

input_file = []

processingOptions = ProcessingOptions()

if len(sys.argv) > 2:
    # Have input file as well as output file
    input_filename = sys.argv[1]
    output_filename = sys.argv[2]

    if Path(input_filename).exists():
        input_path = Path(input_filename)
        with input_path.open() as file:
            input_file = file.readlines()
    else:
        print("Input file specified but does not exist. Terminating.")
elif len(sys.argv) == 1:
    print("No parameters. Terminating")
    sys.exit()
else:
    output_filename = sys.argv[1]

    input_file = sys.stdin.readlines()

if len(input_file) == 0:
    print("Empty input file. Terminating")
    sys.exit()

slideNumber = 1

bulletRegex = re.compile("^(\s)*(\*)(.*)")
numberRegex = re.compile("^(\s)*(\d+)\.(.*)")
metadataRegex = re.compile("^(.+):(.+)")

graphicRE = "!\[(.*?)\]\((.+?)\)"
clickableGraphicRE = "\[" + graphicRE + "\]\((.+?)\)"
graphicRegex = re.compile(graphicRE)
clickableGraphicRegex = re.compile(clickableGraphicRE)

neitherClickableGraphicRegex = re.compile(graphicRE + "(.*?)" + graphicRE)
leftClickableGraphicRegex = re.compile(clickableGraphicRE + "(.*?)" + graphicRE)
rightClickableGraphicRegex = re.compile(graphicRE + "(.*?)" + clickableGraphicRE)
bothClickableGraphicRegex = re.compile(
    clickableGraphicRE + "(.*?)" + clickableGraphicRE
)

linkRegex = re.compile("^\[(.+)\]\((.+)\)")
twoUpRegex = re.compile("^\|(.+?)\|(.+?)\|")
footnoteDefinitionRegex = re.compile("^\[\^(.+?)]: (.+)")
spanClassRegex = re.compile("<span( )*class=")
spanStyleRegex = re.compile("<span( )*style=")
RGBRegex = re.compile("#([0-9a-fA-F]{6})")
slideHrefRegex = re.compile("(.+)\[(.+)\]")
# slideHrefRegex = re.compile("\[(.+)\]\(.+\)")
anchorRegex = re.compile("^<a id=[\"'](.+)[\"']></a>")
dynamicMetadataRegex = re.compile("^<!-- md2pptx: (.+): (.+) -->")


# Default slide layout enumeration
processingOptions.setOptionValuesArray(
    [
        ["titleSlideLayout", 0],
        ["sectionSlideLayout", 1],
        ["contentSlideLayout", 2],
        ["titleOnlyLayout", 5],
        ["blanklayout", 6],
    ]
)

# Abbreviation Dictionary
abbrevDictionary = {}

# Abbreviation Runs Dictionary
abbrevRunsDictionary = {}

# Footnote runs Dictionary
footnoteRunsDictionary = {}

# Extract metadata
metadata_lines = []
afterMetadataAndHTML = []


TOCruns = []
SectionSlides = {}

inMetadata = True
in_comment = False
inHTML = False
inCode = False

# Pass 1: Strip out comments and metadata, storing the latter
for line in input_file:
    if line.lstrip().startswith("<!-- md2pptx: "):
        # md2pptx dynamic metadata so keep it
        afterMetadataAndHTML.append(line)

    if line.lstrip().startswith("<!--"):
        if line.rstrip().endswith("-->"):
            # Note: Not taking text after end of comment
            continue
        else:
            in_comment = True
            continue

    elif line.rstrip().endswith("-->"):
        # Note: Not taking text after end of comment
        in_comment = False
        continue

    elif in_comment is True:
        continue

    elif (line.lstrip()[:1] == "<") & (inCode is False):
        lineLstrip = line.lstrip()
        if startswithOneOf(lineLstrip, ["<a id=", "<span "]):
            # Line goes to post-metadata array
            afterMetadataAndHTML.append(line)

        elif startswithOneOf(lineLstrip, ["<code>", "<pre>"]):
            inCode = True
            afterMetadataAndHTML.append(line)

        elif startswithOneOf(lineLstrip, ["</code>", "</pre>"]):
            inCode = False
            afterMetadataAndHTML.append(line)
        else:
            inHTML = True
        continue

    elif line.startswith("```"):
        inCode = ~inCode
        # afterMetadataAndHTML.append(line)

    elif line.lstrip()[:1] == "#":
        # Heading has triggered end of metadata and end of HTML
        inMetadata = False
        inHTML = False

    elif inHTML:
        continue

    elif inCode:
        afterMetadataAndHTML.append(line)
        continue

    elif line == "\n":
        # Blank line has triggered end of metadata
        inMetadata = False

    if inMetadata is True:
        # Line goes to metadata array
        metadata_lines.append(line)

    else:
        # Line goes to post-metadata array
        afterMetadataAndHTML.append(line)

want_numbers_headings = False
want_numbers_content = False

processingOptions.setOptionValues("slideTemplateFile", "")

######################################################################################
#                                                                                    #
# Set default, presentation and current values for some key options                  #
#                                                                                    #
######################################################################################

processingOptions.setOptionValues("pageTitleSize", 30)

processingOptions.setOptionValues("baseTextSize", 18)

processingOptions.setOptionValues("baseTextDecrement", 2)

# Code defaults
processingOptions.setOptionValuesArray(
    [
        ["codeForeground", "000000"],
        ["codeBackground", "DFFFDF"],
        ["codeColumns", 80],
        ["fixedPitchHeightWidthRatio", 1.2],
    ]
)

# Text defaults
processingOptions.setOptionValuesArray(
    [
        ["italicItalic", True],
        ["italicColour", ""],
        ["boldBold", True],
        ["boldColour", ""],
    ]
)

# Tables defaults
processingOptions.setOptionValuesArray(
    [
        ["compactTables", 0],
        ["addTableLines", "no"],
        ["addTableColumnLines", []],
        ["addTableRowLines", []],
        ["addTableLineWidth", 1],
        ["addTableLineCount", 1],
        ["addTableLineColour", "000000"],
        ["tableMargin", Inches(0.2)],
    ]
)

# Cards defaults
processingOptions.setOptionValuesArray(
    [
        ["cardPercent", 80],
        ["cardLayout", "horizontal"],
        ["cardTitleAlign", "c"],
        ["cardTitlePosition", "above"],
        ["cardShape", "rounded"],
        ["horizontalCardGap", 0.25],
        ["verticalCardGap", 0.15],
        ["cardShadow", False],
        ["cardTitleSize", 0],
        ["cardBorderWidth", 0],
        ["cardBorderColour", ""],
        ["cardColour", ""],
    ]
)


processingOptions.setOptionValues("contentSplit", [1, 1, 1, 1, 1, 1, 1, 1, 1, 1])

processingOptions.setOptionValues("contentSplitDirection", "vertical")

# Number of spaces a single level of indentation is
processingOptions.setOptionValues("indentSpaces", 2)

# Whether titles are adjusted or not
processingOptions.setOptionValues("adjustTitles", True)

# Section defaults
processingOptions.setOptionValuesArray(
    [["sectionTitleSize", 40], ["sectionSubtitleSize", 28]]
)

processingOptions.setOptionValues("monoFont", "Courier")

topHeadingLevel = 1
titleLevel = topHeadingLevel
sectionLevel = titleLevel + 1
contentLevel = sectionLevel + 1
cardLevel = contentLevel + 1

# Abstracts defaults
abstractTitle = processingOptions.setOptionValues("abstractTitle", "")

# Tasks defaults
processingOptions.setOptionValuesArray([["taskSlides", "all"], ["tasksPerPage", 20]])

# Glossary defaults
processingOptions.setOptionValuesArray(
    [
        ["glossaryTitle", "Title"],
        ["glossaryTerm", "Term"],
        ["glossaryMeaning", "Meaning"],
        ["glossaryMeaningWidth", 5],
        ["glossaryTermsPerPage", 20],
    ]
)

# Footnotes defaults
processingOptions.setOptionValuesArray(
    [["footnotesTitle", "Footnotes"], ["footnotesPerPage", 20]]
)

# Table Of Contents defaults
processingOptions.setOptionValuesArray(
    [
        ["tocTitle", "Topics"],
        ["tocStyle", ""],
        ["tocItemHeight", 0],
        ["tocItemColour", ""],
        ["tocRowGap", 0.75],
        ["tocFontSize", 0],
        ["tocLinks", False],
        ["sectionArrows", False],
        ["sectionArrowsColour", ""],
    ]
)

processingOptions.setOptionValues("marginBase", Inches(0.2))

TOCEntries = []


metadata = []


# Space to leave at bottom if numbers
numbersHeight = Inches(0.4)

# If no numbers leave all the above height anyway
processingOptions.setOptionValuesArray(
    [
        ["numbersHeight", numbersHeight],
        ["numbersContentMargin", numbersHeight],
        ["numbersHeadingsMargin", numbersHeight],
    ]
)

######################################################################################
#                                                                                    #
#  Prime for style. metadata                                                         #
#                                                                                    #
######################################################################################

# Background colour class correspondence
bgcolors = {}

# Foreground colour class correspondence
fgcolors = {}

# Emphases class correspondence
emphases = {}

######################################################################################
#                                                                                    #
#  Prime for footnotes                                                               #
#                                                                                    #
######################################################################################

# List of footnote definitions. Each is a (ref, text) pair.
# Also array of names - for quick searching
footnoteDefinitions = []
footnoteReferences = []

maxBlocks = 10

######################################################################################
#                                                                                    #
#  Parse metadata and report on the items found, setting options                     #
#                                                                                    #
######################################################################################

if len(metadata_lines) > 0:
    print("")
    print("Metadata:")
    print("=========")
    print("")
    print("Name".ljust(40) + " " + "Value")
    print("----".ljust(40) + " " + "-----")


for line in metadata_lines:
    matchInfo = metadataRegex.match(line)
    name = matchInfo.group(1).strip()
    value = matchInfo.group(2).strip()
    metadata.append([name, value])

    # Print name as it was typed
    print(name.ljust(40) + " " + value)

    # Lower case name for checking
    name = name.lower()

    if name == "numbers":
        numbersHeight = processingOptions.getCurrentOption("numbersHeight")
        if value.lower() == "yes":
            # Want slide numbers everywhere
            want_numbers_headings = True
            processingOptions.setOptionValues("numbersHeadingsMargin", numbersHeight)

            want_numbers_content = True
            processingOptions.setOptionValues("numbersContentMargin", numbersHeight)
        elif value.lower() == "content":
            # Want slide numbers on content slides but not headings & sections
            want_numbers_headings = False
            want_numbers_content = True
            processingOptions.setOptionValues("numbersContentMargin", numbersHeight)
        else:
            # Don't want slide numbers - but they could still be added by slide master
            # (Can code any other value, including 'no' or omit this metadata type)
            want_numbers_headings = False
            want_numbers_content = False

    elif name == "pagetitlesize":
        processingOptions.setOptionValues(name, float(value))

    elif name == "basetextsize":
        processingOptions.setOptionValues(name, float(value))

    elif name == "basetextdecrement":
        processingOptions.setOptionValues(name, float(value))

    elif name == "sectiontitlesize":
        processingOptions.setOptionValues(name, float(value))

    elif name == "sectionsubtitlesize":
        processingOptions.setOptionValues(name, float(value))

    elif (name == "template") | (name == "master"):
        if value == "Martin Master.pptx":
            slideTemplateFile = "Martin Template.pptx"
        else:
            slideTemplateFile = value
        processingOptions.setOptionValues("slideTemplateFile", slideTemplateFile)

    elif name == "monofont":
        processingOptions.setOptionValues(name, value)

    elif name == "marginbase":
        processingOptions.setOptionValues(name, Inches(float(value)))

    elif name == "tablemargin":
        processingOptions.setOptionValues(name, Inches(float(value)))

    elif name == "tocstyle":
        if value in ["chevron", "circle", "plain"]:
            processingOptions.setOptionValues(name, value)
        else:
            print(
                f'TOCStyle value \'{value}\' unsupported. "chevron" or "circle" required.'
            )

    elif name == "toctitle":
        processingOptions.setOptionValues(name, value)

    elif name == "tocitemheight":
        processingOptions.setOptionValues(name, float(value))

    elif (name == "tocitemcolour") | (name == "tocitemcolor"):
        processingOptions.setOptionValues("tocItemColour", value)

    elif name == "toclinks":
        if value.lower() == "yes":
            processingOptions.setOptionValues(name, True)

    elif name == "sectionarrows":
        if value.lower() == "yes":
            processingOptions.setOptionValues(name, True)

    elif (name == "sectionarrowscolour") | (name == "sectionarrowscolor"):
        processingOptions.setOptionValues("sectionArrowsColour", value)

    elif name == "tocrowgap":
        processingOptions.setOptionValues(name, float(value))

    elif name == "tocfontsize":
        processingOptions.setOptionValues(name, float(value))

    elif name == "compacttables":
        processingOptions.setOptionValues(name, float(value))

    elif name == "abstracttitle":
        processingOptions.setOptionValues(name, value)

    elif name == "boldbold":
        if value.lower() == "no":
            processingOptions.setOptionValues("boldBold", False)

    elif (name == "boldcolour") | (name == "boldcolor"):
        processingOptions.setOptionValues("boldColour", parseThemeColour(value))

    elif name == "italicitalic":
        if value == "no":
            processingOptions.setOptionValues("italicItalic", False)

    elif (name == "italiccolour") | (name == "italiccolor"):
        processingOptions.setOptionValues("italicColour", parseThemeColour(value))

    elif (name == "cardcolour") | (name == "cardcolor"):
        processingOptions.setOptionValues("cardColour", parseThemeColour(value))

    elif (name == "cardbordercolour") | (name == "cardbordercolor"):
        processingOptions.setOptionValues("cardBorderColour", parseThemeColour(value))

    elif name == "cardborderwidth":
        processingOptions.setOptionValues(name, float(value))

    elif name == "cardtitlesize":
        processingOptions.setOptionValues(name, float(value))

    elif name == "cardshadow":
        if value.lower() == "yes":
            processingOptions.setOptionValues(name, True)

    elif name == "cardpercent":
        processingOptions.setOptionValues(name, float(value))

    elif name == "cardlayout":
        if value in ["horizontal", "vertical"]:
            processingOptions.setOptionValues(name, value)
        else:
            print(
                f'CardLayout value \'{value}\' unsupported. "horizontal" or "vertical" required.'
            )

    elif name == "cardshape":
        if value in ["squared", "rounded"]:
            processingOptions.setOptionValues(name, value)
        else:
            print(
                f'CardShape value \'{value}\' unsupported. "squared" or "rounded" required.'
            )

    elif name == "cardtitleposition":
        if value in ["above", "inside"]:
            processingOptions.setOptionValues(name, value)
        else:
            print(
                f'CardTitlePosition value \'{value}\' unsupported. "inside" or "above" required.'
            )

    elif name == "cardtitlealign":
        val1l = value[:1].lower()
        if val1l in ["l", "r", "c"]:
            processingOptions.setOptionValues(name, val1l)
        else:
            print(f"CardAlign value '{value}' unsupported.")

    elif name == ["horizontalcardgap", "verticalcardgap"]:
        processingOptions.setOptionValues(name, float(value))

    elif name == "contentsplit":
        splitValue = value.split()
        cs = []
        for v in splitValue:
            cs.append(int(v))

        # Extend to maximum allowed
        needMore = maxBlocks - len(cs)
        for _ in range(needMore):
            cs.append(1)

        processingOptions.setOptionValues("contentSplit", cs)

    elif name in ["contentsplitdirection", "contentsplitdirn"]:
        if value in [
            "vertical",
            "horizontal",
            "v",
            "h",
            "default",
            "pres",
            "pop",
            "prev",
        ]:
            if value in ["vertical", "horizontal"]:
                adjustedValue = value
            elif value == "v":
                adjustedValue = "vertical"
            elif value == "h":
                adjustedValue = "horizontal"
            else:
                adjustedValue = value

            processingOptions.setOptionValues("contentSplitDirection", adjustedValue)

        else:
            print(
                f'{name} value \'{value}\' unsupported. "vertical" or "horizontal" required.'
            )

    elif name == "taskslides":
        processingOptions.setOptionValues(name, value)

    elif name == "tasksperpage":
        processingOptions.setOptionValues(name, int(value))

    elif name in [
        "titleslidelayout",
        "sectionslidelayout",
        "contentslidelayout",
        "titleonlylayout",
        "blanklayout",
    ]:
        processingOptions.setOptionValues(name, int(value))

    elif name == "numbersheight":
        numbersHeight = Inches(float(value))

        # If no numbers leave all the above height anyway
        processingOptions.setOptionValues("numbersHeight", numbersHeight)
        processingOptions.setOptionValues("numbersContentMargin", numbersHeight)
        processingOptions.setOptionValues("numbersHeadingsMargin", numbersHeight)

    elif name == "glossarytitle":
        processingOptions.setOptionValues(name, value)

    elif name == "glossaryterm":
        processingOptions.setOptionValues(name, value)

    elif name == "glossarymeaning":
        processingOptions.setOptionValues(name, value)

    elif name == "glossarymeaningwidth":
        processingOptions.setOptionValues(name, int(value))

    elif name == "glossarytermsperpage":
        processingOptions.setOptionValues(name, int(value))

    elif name == "footnotesperpage":
        processingOptions.setOptionValues(name, int(value))

    elif name == "footnotestitle":
        processingOptions.setOptionValues(name, value)

    # Following relate to styling and don't use Processing Options class

    elif name.startswith("style.bgcolor."):
        (check, colour) = parseRGB("#" + value)
        if check:
            # Valid RGB hex value
            bgcolors[spanClass] = colour
        else:
            print(f"Invalid value for {name} - {value}. Ignoring.")

    elif name.startswith("style.fgcolor."):
        spanClass = name[14:]
        (check, colour) = parseRGB("#" + value)
        if check:
            # Valid RGB hex value
            fgcolors[spanClass] = colour
        else:
            print(f"Invalid value for {name} - {value}. Ignoring.")

    elif name.startswith("style.emphasis."):
        spanClass = name[15:]
        emphases[spanClass] = value

    elif name in ["codeforeground", "codebackground"]:
        processingOptions.setOptionValues(name, value)

    elif name == "fpratio":
        processingOptions.setOptionValues("fixedPitchHeightWidthRatio", float(value))

    elif name == "codecolumns":
        processingOptions.setOptionValues(name, int(value))

    elif name == "topheadinglevel":
        titleLevel = int(value)
        sectionLevel = titleLevel + 1
        contentLevel = sectionLevel + 1
        cardLevel = contentLevel + 1

    elif name == "indentspaces":
        processingOptions.setOptionValues(name, int(value))

    elif name == "adjusttitles":
        if value == "no":
            processingOptions.setOptionValues(name, False)

    elif name in ["addtablelines", "addtablelinecolour"]:
        processingOptions.setOptionValues(name, value)

    elif name in ["addtablecolumnlines", "addtablerowlines"]:
        processingOptions.setOptionValues(name, sortedNumericList(value))

    elif name in ["addtablelinecount", "addtablelinewidth"]:
        processingOptions.setOptionValues(name, int(value))
    
    elif name == "hidemetadata":
        if value == "style":
            processingOptions.hideMetadataStyle = True

slideTemplateFile = processingOptions.getCurrentOption("slideTemplateFile")
if slideTemplateFile != "":
    originalSlideTemplateFile = slideTemplateFile
    if Path(os.path.expanduser(slideTemplateFile)).exists():
        # We can successfully expand the path to pick up the file
        slideTemplateFile = os.path.expanduser(slideTemplateFile)
    else:
        # Slide template file is not present if we expand path
        script_path = os.path.dirname(__file__)
        slideTemplateFile = script_path + os.sep + slideTemplateFile
        if not Path(slideTemplateFile).exists():
            print(
                f"\nTemplate file {originalSlideTemplateFile} does not exist. Terminating."
            )
            sys.exit()

    print(f"\nUsing {slideTemplateFile} as base for presentation")

if slideTemplateFile == "":
    # Use default slide deck that comes with python-pptx as base
    prs = Presentation()
    print("\nNo slide to document metadata on. Continuing without it.")

    templateSlideCount = 0
else:
    # Use user-specified presentation as base
    prs = Presentation(slideTemplateFile)

    # If there is a slide to use fill it with metadata
    templateSlideCount = len(prs.slides)
    if templateSlideCount > 0:
        createProcessingSummarySlide(prs, metadata)
        print("\nWriting processing summary slide with metadata on it.")
    else:
        print("\nNo slide to document metadata on. Continuing without it.")

print("")
print("Slides:")
print("=======")
print("")

inBlock = False
inList = False
inTable = False
inCard = False
inTitle = False

blockType = ""
slideTitle = ""
slideSubtitle = ""
bullets = []
tableRows = []
cards = []
code = []
inCode = False
inHTMLCode = False
inFencedCode = False
notes_text = ""
slide = None
tasks = []
sequence = []

slideHrefs = {}
href_runs = {}

# Each of these is a picture, then a href, then a tooltip - as a tuple
pictureInfos = []

# Pass 2: Concatenate lines with continuations
previousLine = "\n"
linesAfterConcatenation = []

for line in afterMetadataAndHTML:
    if startswithOneOf(line, ["<pre>", "<code>"]):
        # These are around code lines
        linesAfterConcatenation.append(line)
        inHTMLCode = True

    elif startswithOneOf(line, ["</pre>", "</code>"]):
        # These are around code lines
        linesAfterConcatenation.append(line)
        inHTMLCode = False

    elif line.startswith("```"):
        linesAfterConcatenation.append(line)
        inCode = not inCode

    elif line == "\n":
        # This is a blank line so copy it over
        linesAfterConcatenation.append(line)

    elif previousLine == "\n":
        # Previous line was blank so copy this one over
        linesAfterConcatenation.append(line)

    elif line.startswith("<!-- md2pptx: "):
        # This is a dynamic metadata line so keep it separate
        linesAfterConcatenation.append(line)

    elif line.startswith("<a id="):
        # This is an anchor line so keep it separate
        linesAfterConcatenation.append(line)

    elif line.lstrip() == "":
        # This is an empty line
        linesAfterConcatenation.append(line)

    else:
        # Previous line was not blank and nor is this one so consider concatenation
        if line.lstrip()[0] not in "*#\|0123456789!":
            if (
                (previousLine[0:2] != "# ")
                & (previousLine[0:3] != "## ")
                & (previousLine[0:4] != "    ")
                & (inCode is False)
                & (inHTMLCode is False)
            ):
                # Previous line was not Heading Level 1 or 2 and we're not in code so concatenate
                linesAfterConcatenation[-1] = (
                    linesAfterConcatenation[-1].rstrip() + " " + line.lstrip()
                )
            else:
                linesAfterConcatenation.append(line)

        else:
            linesAfterConcatenation.append(line)

    # Store previous line to see if it was H1 or blank
    previousLine = line

# Pass 3: Get footnote definitions
metadataLinenumber = 0
for line in linesAfterConcatenation:
    line = line.rstrip()
    if m := footnoteDefinitionRegex.match(line):
        fnRef = m.group(1).strip()
        fnText = m.group(2).strip()
        footnoteDefinitions.append([fnRef, fnText])
        footnoteReferences.append(fnRef)

        linesAfterConcatenation[metadataLinenumber] = "<ignoreme>"
    metadataLinenumber += 1

# Pass 4: Main pass over the input file, now that footnote
# references have been gathered
for line in linesAfterConcatenation:
    # Remove trailing white space
    line = line.rstrip()
    
    # Convert tabs to spaces
    line = line.replace("\t", " " * processingOptions.getCurrentOption("indentSpaces"))

    if line == "<ignoreme>":
        # Line was taken care of in the previous pass
        continue

    if startswithOneOf(line, ["<pre>", "<code>"]):
        code.append([])
        inCode = True
        inHTMLCode = True
        inTable = False
        inTitle = False

    if startswithOneOf(line, ["</pre>", "</code>"]):
        inCode = False
        inHTMLCode = False
        inTitle = False

    if line.startswith("```"):
        inCode = not inCode
        if inCode:
            # Just entered code
            code.append([])
            blockType = "code"
            inTable = False
        else:
            # Just exited code - but add closing line
            code[-1].append(line)
        inFencedCode = not inFencedCode
        inTitle = False

    if inCode or inHTMLCode or inFencedCode:
        if len(code) == 0:
            code.append([])
        code[-1].append(line)

        # If first line of code then mark the current sequence entry as "code"
        if len(code[-1]) == 1:
            sequence.append("code")

        inTitle = False
    if (
        (line == "")
        & (inCode is True)
        & (inHTMLCode is False)
        & (inFencedCode is False)
    ):
        inCode = False
        inTitle = False

    if (line.startswith("    ")) & (inList is False):
        # Only list items and code can be indented by 4 characters
        if inCode is False:
            code.append([])
            blockType = "code"
            code[-1].append(line[4:])
            inCode = True
        inTitle = False

    # Rewrite horizontal rule as a heading 3 with non-breaking space
    if startswithOneOf(line, ["<hr/>", "---", "***", "___"]):
        line = "### &nbsp;"
        inTitle = True

    # Taskpaper task
    if line[:1] == "-":
        # Get start of attributes
        attributesStart = line.find("@")

        # Get text up to attributes
        if attributesStart == -1:
            text = line[2:]
        else:
            text = line[2 : attributesStart - 1]

        # Attempt to extract @due information
        startDue = line.find("@due(")
        if startDue > -1:
            startDue += 5
            endDue = line.find(")", startDue)
            if endDue > -1:
                dueDate = line[startDue:endDue]
        else:
            dueDate = ""

        # Attempt to extract @tags information
        startTags = line.find("@tags(")
        if startTags > -1:
            startTags += 6
            endTags = line.find(")", startTags)
            if endTags > -1:
                tags = line[startTags:endTags]
        else:
            tags = ""

        # Attempt to extract @done information
        startDone = line.find("@done(")
        if startDone > -1:
            startDone += 6
            endDone = line.find(")", startDone)
            if endDone > -1:
                done = line[startDone:endDone]
        else:
            done = ""

        tasks.append([slideNumber + 1, text, dueDate, tags, done])
        inTitle = False

    elif line.startswith("<a id="):
        # Anchor on whatever slide we're on
        if hrefMatch := anchorRegex.match(line):
            href = hrefMatch.group(1)
            if (href != "") & (href in slideHrefs.keys()):
                print(f"Heading Reference redefined: '{href}' for slide {slideNumber}")
        inTitle = False

    elif line.startswith("<!-- md2pptx: "):
        # Dynamic metadata line
        inTitle = False
        if DMMatch := dynamicMetadataRegex.match(line):
            metadataKey = DMMatch.group(1).lower()
            metadataValue = DMMatch.group(2).lower()
            if (metadataKey != "") & (metadataValue != ""):
                # Valid metadata pair so parse key / value - and apply if valid
                if metadataKey == "compacttables":
                    # Font size for tables
                    processingOptions.dynamicallySetOption(
                        metadataKey, metadataValue.lower(), "float"
                    )

                elif metadataKey == "pagetitlesize":
                    # Page Title Font size
                    processingOptions.dynamicallySetOption(
                        metadataKey, metadataValue, "float"
                    )

                elif metadataKey == "cardpercent":
                    # Cards' vertical percent of content area
                    processingOptions.dynamicallySetOption(
                        metadataKey, metadataValue, "float"
                    )

                elif metadataKey == "cardlayout":
                    # Cards' layout - horizontal or vertical
                    processingOptions.dynamicallySetOption(
                        metadataKey, metadataValue, ""
                    )

                elif metadataKey == "basetextsize":
                    # Base text size
                    processingOptions.dynamicallySetOption(
                        metadataKey, metadataValue, "float"
                    )

                elif metadataKey == "basetextdecrement":
                    # Base text decrement
                    processingOptions.dynamicallySetOption(
                        metadataKey, metadataValue, "float"
                    )

                # Note: Actual value handling prevents using dynamicallySetOption
                elif metadataKey == "cardtitlealign":
                    # Card title alignment
                    processingOptions.dynamicallySetOption(
                        metadataKey, metadataValue.lower(), ""
                    )

                elif metadataKey == "cardtitleposition":
                    # Card title position - above or inside
                    processingOptions.dynamicallySetOption(
                        metadataKey, metadataValue, ""
                    )

                elif metadataKey in ["horizontalcardgap", "verticalcardgap"]:
                    processingOptions.dynamicallySetOption(
                        metadataKey, metadataValue, "float"
                    )

                # Note: Actual value handling prevents using dynamicallySetOption
                elif metadataKey == "contentsplit":
                    # Proportions for each content element on a slide
                    if metadataValue == "default":
                        contentSplit = processingOptions.getDefaultOption(
                            "contentSplit"
                        )
                    elif metadataValue == "pres":
                        contentSplit = processingOptions.getPresentationOption(
                            "contentSplit"
                        )
                    elif metadataValue in ["pop", "prev"]:
                        processingOptions.popCurrentOption("contentSplit")
                        contentSplit = processingOptions.getPresentationOption(
                            "contentSplit"
                        )
                    else:
                        splitValue = metadataValue.split()
                        contentSplit = []
                        for v in splitValue:
                            contentSplit.append(int(v))

                        # Extend to maximum allowed
                        needMore = maxBlocks - len(contentSplit)
                        for _ in range(needMore):
                            contentSplit.append(1)
                    processingOptions.dynamicallySetOption(
                        "contentSplit", contentSplit, ""
                    )

                elif metadataKey in ["contentsplitdirection", "contentsplitdirn"]:
                    if metadataValue in [
                        "vertical",
                        "horizontal",
                        "v",
                        "h",
                        "pres",
                        "default",
                        "pop",
                        "prev",
                    ]:
                        if metadataValue == "v":
                            adjustedValue = "vertical"
                        elif metadataValue == "h":
                            adjustedValue = "horizontal"
                        else:
                            adjustedValue = metadataValue

                        processingOptions.dynamicallySetOption(
                            "contentSplitDirection",
                            adjustedValue,
                            "",
                        )

                    else:
                        print(
                            f'{metadataKey} value \'{metadataValue}\' unsupported. "vertical" or "horizontal" required.'
                        )

                elif metadataKey in ["codeforeground", "codebackground"]:
                    processingOptions.dynamicallySetOption(
                        metadataKey,
                        metadataValue,
                        "",
                    )

                elif metadataKey == "fpratio":
                    # Fixed Pitch font height to width ratio
                    processingOptions.dynamicallySetOption(
                        "fixedPitchHeightWidthRatio",
                        metadataValue,
                        "float",
                    )

                elif metadataKey == "codecolumns":
                    processingOptions.dynamicallySetOption(
                        metadataKey,
                        metadataValue,
                        "int",
                    )

                elif metadataKey == "indentspaces":
                    # Spaces representing a single indentation level
                    processingOptions.dynamicallySetOption(
                        metadataKey,
                        metadataValue,
                        "int",
                    )

                elif metadataKey in ["addtablecolumnlines", "addtablerowlines"]:
                    processingOptions.dynamicallySetOption(
                        metadataKey,
                        metadataValue,
                        "sortednumericlist",
                    )

                elif metadataKey in ["addtablelinecount", "addtablelinewidth"]:
                    processingOptions.dynamicallySetOption(
                        metadataKey,
                        metadataValue,
                        "int",
                    )

                elif metadataKey in ["addtablelines", "addtablelinecolour"]:
                    processingOptions.dynamicallySetOption(
                        metadataKey,
                        metadataValue,
                        "",
                    )

                else:
                    # Invalid dynamic metadata specification
                    print(f"Invalid dynamic metadata key: '{metadataKey}' in '{line}'")

    elif line.startswith("#"):
        if line[:cardLevel] == "#" * cardLevel:
            # Card on an existing slide
            inCard = True

            # If there is an outstanding href then store it
            if href != "":
                slideHrefs[href] = slideNumber + 1

            # Get card title text and any href
            cardName, href = parseTitleText(line[cardLevel:])

            # Create information about a card_title
            cardBullets = []
            cards.append([cardName])
            inTitle = False	

        else:
            # One of Content, Section, or Title slide
            if inBlock is True:
                # Create the previous slide
                slideInfo = SlideInfo(
                    slideTitle,
                    slideSubtitle,
                    blockType,
                    bullets,
                    tableRows,
                    cards,
                    code,
                    sequence,
                )
                slideNumber, slide, sequence = createSlide(prs, slideNumber, slideInfo)

                # Register the previous slide's href - if there was one
                if href != "":
                    slideHrefs[href] = slideNumber

            if line[:contentLevel] == "#" * contentLevel:
                # Heading Level 3 - slide
                thisLevel = contentLevel
                blockType = "content"

            elif line[:sectionLevel] == "#" * sectionLevel:
                # Heading Level 2 - section
                thisLevel = sectionLevel
                blockType = "section"
                inTitle = True

            elif line[:titleLevel] == "#" * titleLevel:
                # Heading Level 1 - slide title
                thisLevel = titleLevel
                blockType = "title"
                inTitle = True
            else:
                inTitle = False

            # Get slide title text and any href
            slideTitle, href = parseTitleText(line[thisLevel:])

            inBlock = True
            inList = False
            inTable = False
            inCard = False
            slideSubtitle = ""
            bullets = []
            tableRows = []
            cards = []
            code = []

            if (notes_text != "") & (slide != None):
                createSlideNotes(slide, notes_text)

            notes_text = ""

        # Check whether any heading reference is a duplicate
        if (href != "") & (href in slideHrefs.keys()):
            print(f"Heading Reference redefined: '{href}' for slide {slideNumber}")

    elif match := bulletRegex.match(line):
        # Bulleted list
        bulletLine = match.group(3).lstrip()
        bulletLevel = calculateIndentationLevel(
            match.start(2), processingOptions.getCurrentOption("indentSpaces")
        )
        bulletType = "bulleted"
        if inCard:
            cardBullets.append([bulletLevel, bulletLine, bulletType])
            cardsLength = len(cards)
            if len(cards[cardsLength - 1]) == 1:
                cards[cardsLength - 1].append(cardBullets)
            else:
                cards[cardsLength - 1][1] = cardBullets
        else:
            bullets.append([bulletLevel, bulletLine, bulletType])
        if inList is False:
            sequence.append("list")
        inList = True
        inTable = False
        inTitle = False

    elif match := numberRegex.match(line):
        # Numbered list
        bulletLine = match.group(3).lstrip()
        bulletLevel = calculateIndentationLevel(
            match.start(2), processingOptions.getCurrentOption("indentSpaces")
        )
        bulletType = "numbered"
        if inCard:
            cardBullets.append([bulletLevel, bulletLine, bulletType])
            cardsLength = len(cards)
            if len(cards[cardsLength - 1]) == 1:
                cards[cardsLength - 1].append(cardBullets)
            else:
                cards[cardsLength - 1][1] = cardBullets
        else:
            bullets.append([bulletLevel, bulletLine, bulletType])
        if inList is False:
            sequence.append("list")
        inList = True
        inTable = False
        inTitle = False

    elif (graphicRegex.match(line) != None) | (
        clickableGraphicRegex.match(line) != None
    ):
        # There is at least one graphic in the line - whether clickable or not
        if inTable is False:
            blockType = "table"
            tableRows.append([])
            inTable = True
            sequence.append("table")
            inList = False
            inCard = False

        # Create a table row
        tableRow = []

        if len(graphicRegex.findall(line)) == 2:
            # Two graphics - whether clickable or not - on same line
            if matches := bothClickableGraphicRegex.match(line):
                leftGraphic = (
                    "[![" + matches[1] + "](" + matches[2] + ")](" + matches[3] + ")"
                )

                rightGraphic = (
                    "[![" + matches[5] + "](" + matches[6] + ")](" + matches[7] + ")"
                )

            elif matches := leftClickableGraphicRegex.match(line):
                leftGraphic = (
                    "[![" + matches[1] + "](" + matches[2] + ")](" + matches[3] + ")"
                )

                rightGraphic = "![" + matches[5] + "](" + matches[6] + ")"

            elif matches := rightClickableGraphicRegex.match(line):
                leftGraphic = "![" + matches[1] + "](" + matches[2] + ")"

                rightGraphic = (
                    "[![" + matches[4] + "](" + matches[5] + ")](" + matches[6] + ")"
                )

            else:
                matches = neitherClickableGraphicRegex.match(line)
                leftGraphic = "![" + matches[1] + "](" + matches[2] + ")"

                rightGraphic = "![" + matches[4] + "](" + matches[5] + ")"

            tableRow.append(leftGraphic)
            tableRow.append(rightGraphic)

        else:
            # One graphic - whether clickable or not - on the line

            tableRow.append(line)

        # Add table row to saved table rows
        tableRows[-1].append(tableRow)
        inTitle = False

    elif line[:1] == "|":
        # Table or side-by-side
        if inTable is False:
            blockType = "table"
            tableRows.append([])
            inTable = True
            sequence.append("table")
            inList = False
            inCard = False

        # Create a table row - but with (maybe empty) junk before and after
        words = line.split("|")
        tableRow = []
        for cell in words:
            tableRow.append(cell)

        # Remove first element
        tableRow.pop(0)

        # Remove last element - if blank
        if cell == "":
            tableRow.pop()

        # Add clean table row to saved table rows
        tableRows[-1].append(tableRow)
        inTitle = False

    else:
        # Not in a table
        inTable = False
        
        if not inCode:
            # Must be a slide note line or a subtitle line
            if line == "":
                inTitle = False
            if inTitle:
                slideSubtitle = slideSubtitle + "\n" + line
            elif startswithOneOf(line, ["</pre>", "</code>"]) is False:
                notes_text = notes_text + "\n" + line

######################################################################################
#                                                                                    #
# Finish off last slide                                                              #
#                                                                                    #
######################################################################################
if (inBlock is True) | (inCode is True) | (inTable is True):
    slideInfo = SlideInfo(
        slideTitle, slideSubtitle, blockType, bullets, tableRows, cards, code, sequence
    )
    slideNumber, slide, sequence = createSlide(prs, slideNumber, slideInfo)

    if href != "":
        slideHrefs[href] = slideNumber

    if (notes_text != "") & (slide != None):
        createSlideNotes(slide, notes_text)

    notes_text = ""

######################################################################################
#                                                                                    #
# Add a footnotes slide - if there were any footnote definitions                     #
#                                                                                    #
######################################################################################
if len(footnoteDefinitions) > 0:
    slideNumber, footnoteSlides = createFootnoteSlides(
        prs, slideNumber, footnoteDefinitions
    )

    footnotesPerPage = processingOptions.getCurrentOption("footnotesPerPage")
    # Fix up any footnote slide hyperlinks
    footnoteNumber = -1
    for footnoteRun in footnoteRunsDictionary.keys():
        footnoteNumber += 1
        run = footnoteRunsDictionary[footnoteRun]

        footnoteSlideNumber = int(footnoteNumber / footnotesPerPage)
        createRunHyperlinkOrTooltip(run, footnoteSlides[footnoteSlideNumber], "")

######################################################################################
#                                                                                    #
# Add a dictionary slide - if there were any abbr elements encountered               #
#                                                                                    #
######################################################################################
if len(abbrevDictionary) > 0:
    glossaryTermsPerPage = processingOptions.getCurrentOption("glossaryTermsPerPage")
    slideNumber, glossarySlides = createGlossarySlides(
        prs, slideNumber, abbrevDictionary
    )
    # Fix up internal glossary hyperlinks
    abbrevNumber = -1
    for abbreviation in sorted(abbrevRunsDictionary.keys()):
        abbrevNumber += 1
        runs = abbrevRunsDictionary[abbreviation]
        for run in runs:
            # Add tooltip for glossary definition
            glossarySlideNumber = int(abbrevNumber / glossaryTermsPerPage)
            createRunHyperlinkOrTooltip(
                run, glossarySlides[glossarySlideNumber], abbrevDictionary[abbreviation]
            )

######################################################################################
#                                                                                    #
# Add final slide - or more than one - with any Taskpaper tasks in                   #
#                                                                                    #
######################################################################################
taskSlides = processingOptions.getCurrentOption("taskSlides")

if (len(tasks) > 0) & (taskSlides != "none"):
    # Turn tasks into a table slide

    # Might need to winnow slides
    if taskSlides != "all":
        complete = []
        incomplete = []
        for task in tasks:
            sNum, taskText, dueDate, tags, done = task
            if done == "":
                incomplete.append(task)
            else:
                complete.append(task)

        if (taskSlides == "separate") & (len(tasks) > 0):
            want_task_slides = True
        elif (taskSlides == "remaining") & (len(incomplete) > 0):
            want_task_slides = True
        elif (taskSlides == "done") & (len(complete) > 0):
            want_task_slides = True
        else:
            want_task_slides = False
    else:
        want_task_slides = True

    if want_task_slides:
        if taskSlides != "separate":
            createTaskSlides(prs, slideNumber, tasks, "Tasks")
        else:
            createTaskSlides(prs, slideNumber, complete, "Completed Tasks")
            createTaskSlides(prs, slideNumber, incomplete, "Incomplete Tasks")

######################################################################################
#                                                                                    #
# Make any TOC / Section-related links                                               #
#                                                                                    #
######################################################################################
if processingOptions.getCurrentOption("tocLinks"):
    # Linkify section items
    for run in TOCruns:
        createRunHyperlinkOrTooltip(run, SectionSlides[run.text])

if processingOptions.getCurrentOption("sectionArrows"):
    # Add navigation arrows between section slides
    sectionArrowsColour = processingOptions.getCurrentOption("sectionArrowsColour")

    buttonTop = prs.slide_height - Inches(2 / 3)
    forwShape = None

    previousSection = None
    for sectionNumber, sectionSlide in enumerate(SectionSlides):
        slide = SectionSlides[sectionSlide]
        if sectionNumber == 0:
            TOCslide = slide

        if forwShape != None:
            createShapeHyperlinkAndTooltip(forwShape, slide, "Next Section")

        buttonShapes = []
        if sectionNumber > 1:
            # Need backwards arrow
            backShape = slide.shapes.add_shape(
                MSO_SHAPE.ACTION_BUTTON_BACK_OR_PREVIOUS,
                prs.slide_width / 2 - Inches(2 / 3),
                buttonTop,
                Inches(1 / 3),
                Inches(1 / 3),
            )

            createShapeHyperlinkAndTooltip(backShape, previousSlide, "Previous Section")

            buttonShapes.append(backShape)

        # Always need home arrow - except for TOC
        if sectionNumber > 0:
            homeShape = slide.shapes.add_shape(
                MSO_SHAPE.ACTION_BUTTON_HOME,
                prs.slide_width / 2 - Inches(1 / 6),
                buttonTop,
                Inches(1 / 3),
                Inches(1 / 3),
            )

            createShapeHyperlinkAndTooltip(homeShape, TOCslide, "Table Of Contents")

            buttonShapes.append(homeShape)

        if (sectionNumber < len(SectionSlides) - 1) & (sectionNumber > 0):
            # Need forwards
            forwShape = slide.shapes.add_shape(
                MSO_SHAPE.ACTION_BUTTON_FORWARD_OR_NEXT,
                prs.slide_width / 2 + Inches(1 / 3),
                buttonTop,
                Inches(1 / 3),
                Inches(1 / 3),
            )

            buttonShapes.append(forwShape)

        else:
            forwShape = None

        # Fix background colour of the buttons
        if sectionArrowsColour != "":
            for buttonShape in buttonShapes:
                buttonShape.fill.solid()
                buttonShape.fill.fore_color.rgb = RGBColor.from_string(
                    sectionArrowsColour
                )

        previousSlide = slide


######################################################################################
#                                                                                    #
# Fix up any internal links                                                          #
#                                                                                    #
######################################################################################
xrefCheck_errors = False
for href in href_runs.keys():
    run = href_runs[href]
    if href in slideHrefs.keys():
        createRunHyperlinkOrTooltip(
            run, prs.slides[slideHrefs[href] - 2 + templateSlideCount], ""
        )
    else:
        # No id defined with that name
        if not xrefCheck_errors:
            # First time in this run a cross reference error occurred
            xrefCheck_errors = True
            print("\nHyperlink Reference Errors")
            print("--------------------------")

        print(
            "Slide "
            + str(prs.slides.index(SlideFromRun(run)) + 1 - templateSlideCount)
            + f": '{href}'"
        )

# Each picture appears in pictures
# There's a corresponding entry in picture_Hrefs
# There's a corresponding entry in picture_tooltips

# fix up any clickable picture links
picture_count = len(pictureInfos)
for p in range(picture_count):
    picture, href, tooltip = pictureInfos[p]

    # Pick up link target - if any
    if href == "#XYZZY-None":
        target = None
    else:
        if href[1:] in slideHrefs.keys():
            # Is an internal link
            target = prs.slides[slideHrefs[href[1:]] - 2 + templateSlideCount]
        else:
            # Is an external Link
            target = href

    createPictureHyperlinkOrTooltip(picture, target, tooltip)

# Write out the finished presentation
prs.save(output_filename)

elapsed_time = time.time() - start_time

print(
    "\nProcessing complete.\nElapsed time: "
    + str(int(1000 * elapsed_time) / 1000)
    + "s"
)

sys.exit()
